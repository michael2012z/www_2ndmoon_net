version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319033900
host=117.89.207.43
name=DesignPattern.Observer
rev=2
targets=DesignPattern.Observer
text=\\%0a %0a[+++'''观察者模式/Observer'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a观察者模式的目的在地，当某一个对象（被观察者）的状态发生变化的时候，其它想要知晓这一改变的对象（观察者）能够得到通知。%0a%0a能够实现这一点的设计方案有很多，但是为了使系统易于复用，应该选择低耦合度的设计方案。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Observer/Observer.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Observer/Observer.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象观察者(Observer)：所有观察者的公共接口。定义一个更新方法（即update()方法），当所观察的对象的状态发生改变时，这个方法是由被观察者所调用。%0a# 具体观察者(ConcreteObserver)：实现Observer接口。具体化update()方法，当被观察者的状态发生变化时，在update()方法中作出相应的反应。%0a# 抽象被观察者(Observable)：被观察者类的公共接口。定义一些管理观察者对象的方法，比如addObserver()、deleteObserver()等，所以它需要维护一个观察者对象的聚集。此外，在逻辑上，还需要实现“通知”的功能，即实现一个notify()方法，在其中调用聚集中观察者的update()方法。但是究竟在什么时候调用update()，这要看具体的实现而定，所以notify()方法并不是必须的。%0a# 具体被观察者(ConcreteObservable)：实现Observable接口，具体化维护聚集的方法和通知的方法。在被观察状态发生改变时，调用观察者的update()方法。%0a%0a[+++''要点：''+++]%0a%0a观察者模式的核心概念就是被观察者对抽象观察者update()方法的调用。这种只面向“接口”的编程，把观察者和被观察者的耦合性降低，使它们可以互相不影响地变化和演绎。%0a%0a要警惕通知过程中的循环调用。因为理论上说，一个类可以既是观察者又是被观察者，作用被观察者，它的观察者聚集里可以有作为观察者的它自己。这时就要保证在它的update()方法中不会再去调notify()，否则将造成死循环。%0a%0a[+++''扩展：''+++]%0a%0a抽象被观察者Observable并不是必须定义为接口，也可以把它定义为抽象类。这两种选择分别有如下的好处：%0a# 定义为接口：具体被观察者可以以自己的方式来维护观察者聚集，可以用Vector，也可以用Hashtable，或者别的。具体被观察者有很大的灵活性。%0a# 定义为抽象类：这时， 聚集由Observable抽象类来维护，notify()方法也在抽象类中实现。这样，所有的具体被观察者就不用再维护聚集了，这是一种比较方便的办法，但也缺少了一些灵活性。如果具体观察者各类较多，而且并不介意怎么维护聚集的话，这是一种好的选择。%0a%0a[+++''应用实例：''+++]%0a%0aListener:\\%0a在使用AWT制作桌面应用的时候，都会使用某种Listener来监听窗口事件。“监听”和“观察”的原理是一样的，当某一事件发生的时候，向监听者发出通知。%0a应该说，监听是观察者模式的一个特例，它的特殊之处有两点：%0a# 观察的对象是“事件”。观察模式中，通知的源动力是一种广泛而谈的变化，事件可算作是一种特例。%0a# 在通知时，被监听者会把事件作为参数传给监听者。观察者模式中，并未指明update()方法是不是需要有参数，这依需要而定，可以有也可以没有。%0a%0a观察者模式实现了一种“广播”的效果，应该场景比较广泛。%0a%0a另外，在Java语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成了Java语言对观察者模式的支持。在需要使用这一模式时，可以考虑直接使用它们。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteObservable.java %0a%0apackage designPatterns.Observer;%0a%0aimport java.util.Enumeration;%0aimport java.util.Vector;%0a%0apublic class ConcreteObservable implements Observable {%0a%0a	private Vector obs = new Vector();%0a	%0a	public void addObserver(Observer o) {%0a		obs.add(o);%0a	}%0a%0a	public void deleteObserver(Observer o) {%0a		obs.remove(o);%0a	}%0a%0a	public void notifyObservers() {%0a		Enumeration enumeration = ((Vector)(obs.clone())).elements();%0a		while(enumeration.hasMoreElements()) {%0a			Observer oo = (Observer)(enumeration.nextElement());%0a			oo.update();%0a//			((Observer)(enumeration.nextElement())).update();%0a		}%0a	}%0a	%0a	public void demo() {%0a		int count = 0;%0a		while (count++ %3c 3) {%0a			try {%0a				Thread.sleep(1000);%0a				notifyObservers();%0a			} catch (Exception e) {%0a				System.out.println(e);%0a			}%0a		}%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ConcreteObserverA.java %0a%0apackage designPatterns.Observer;%0a%0apublic class ConcreteObserverA implements Observer {%0a	public void update() {%0a		System.out.println("ConcreteObserverA got updated.");%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteObserverB.java %0a%0apackage designPatterns.Observer;%0a%0apublic class ConcreteObserverB implements Observer {%0a	public void update() {%0a		System.out.println("ConcreteObserverB got updated.");%0a	}%0a}%0a%0a%0a// Source code from file:  Observable.java %0a%0apackage designPatterns.Observer;%0a%0apublic interface Observable {%0a	public void addObserver(Observer o);%0a	public void deleteObserver(Observer o);%0a	public void notifyObservers();%0a}%0a%0a%0a// Source code from file:  Observer.java %0a%0apackage designPatterns.Observer;%0a%0apublic interface Observer {%0a	public void update();%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Observer;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		ConcreteObservable observable = new ConcreteObservable();%0a		observable.addObserver(new ConcreteObserverA());%0a		observable.addObserver(new ConcreteObserverB());%0a		observable.demo();%0a	}%0a}%0a(:sourcend:)
time=1319036879
author:1319036879=
diff:1319036879:1319033900:=12,13c12%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Observer/Observer.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Observer/Observer.png]]%0a%3c %0a---%0a>  %0a
host:1319036879=117.89.207.43
author:1319033900=
diff:1319033900:1319033900:=1,142d0%0a%3c \\%0a%3c  %0a%3c [+++'''观察者模式/Observer'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 观察者模式的目的在地，当某一个对象（被观察者）的状态发生变化的时候，其它想要知晓这一改变的对象（观察者）能够得到通知。%0a%3c %0a%3c 能够实现这一点的设计方案有很多，但是为了使系统易于复用，应该选择低耦合度的设计方案。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象观察者(Observer)：所有观察者的公共接口。定义一个更新方法（即update()方法），当所观察的对象的状态发生改变时，这个方法是由被观察者所调用。%0a%3c # 具体观察者(ConcreteObserver)：实现Observer接口。具体化update()方法，当被观察者的状态发生变化时，在update()方法中作出相应的反应。%0a%3c # 抽象被观察者(Observable)：被观察者类的公共接口。定义一些管理观察者对象的方法，比如addObserver()、deleteObserver()等，所以它需要维护一个观察者对象的聚集。此外，在逻辑上，还需要实现“通知”的功能，即实现一个notify()方法，在其中调用聚集中观察者的update()方法。但是究竟在什么时候调用update()，这要看具体的实现而定，所以notify()方法并不是必须的。%0a%3c # 具体被观察者(ConcreteObservable)：实现Observable接口，具体化维护聚集的方法和通知的方法。在被观察状态发生改变时，调用观察者的update()方法。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 观察者模式的核心概念就是被观察者对抽象观察者update()方法的调用。这种只面向“接口”的编程，把观察者和被观察者的耦合性降低，使它们可以互相不影响地变化和演绎。%0a%3c %0a%3c 要警惕通知过程中的循环调用。因为理论上说，一个类可以既是观察者又是被观察者，作用被观察者，它的观察者聚集里可以有作为观察者的它自己。这时就要保证在它的update()方法中不会再去调notify()，否则将造成死循环。%0a%3c %0a%3c [+++''扩展：''+++]%0a%3c %0a%3c 抽象被观察者Observable并不是必须定义为接口，也可以把它定义为抽象类。这两种选择分别有如下的好处：%0a%3c # 定义为接口：具体被观察者可以以自己的方式来维护观察者聚集，可以用Vector，也可以用Hashtable，或者别的。具体被观察者有很大的灵活性。%0a%3c # 定义为抽象类：这时， 聚集由Observable抽象类来维护，notify()方法也在抽象类中实现。这样，所有的具体被观察者就不用再维护聚集了，这是一种比较方便的办法，但也缺少了一些灵活性。如果具体观察者各类较多，而且并不介意怎么维护聚集的话，这是一种好的选择。%0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c %0a%3c Listener:\\%0a%3c 在使用AWT制作桌面应用的时候，都会使用某种Listener来监听窗口事件。“监听”和“观察”的原理是一样的，当某一事件发生的时候，向监听者发出通知。%0a%3c 应该说，监听是观察者模式的一个特例，它的特殊之处有两点：%0a%3c # 观察的对象是“事件”。观察模式中，通知的源动力是一种广泛而谈的变化，事件可算作是一种特例。%0a%3c # 在通知时，被监听者会把事件作为参数传给监听者。观察者模式中，并未指明update()方法是不是需要有参数，这依需要而定，可以有也可以没有。%0a%3c %0a%3c 观察者模式实现了一种“广播”的效果，应该场景比较广泛。%0a%3c %0a%3c 另外，在Java语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成了Java语言对观察者模式的支持。在需要使用这一模式时，可以考虑直接使用它们。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteObservable.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c import java.util.Enumeration;%0a%3c import java.util.Vector;%0a%3c %0a%3c public class ConcreteObservable implements Observable {%0a%3c %0a%3c 	private Vector obs = new Vector();%0a%3c 	%0a%3c 	public void addObserver(Observer o) {%0a%3c 		obs.add(o);%0a%3c 	}%0a%3c %0a%3c 	public void deleteObserver(Observer o) {%0a%3c 		obs.remove(o);%0a%3c 	}%0a%3c %0a%3c 	public void notifyObservers() {%0a%3c 		Enumeration enumeration = ((Vector)(obs.clone())).elements();%0a%3c 		while(enumeration.hasMoreElements()) {%0a%3c 			Observer oo = (Observer)(enumeration.nextElement());%0a%3c 			oo.update();%0a%3c //			((Observer)(enumeration.nextElement())).update();%0a%3c 		}%0a%3c 	}%0a%3c 	%0a%3c 	public void demo() {%0a%3c 		int count = 0;%0a%3c 		while (count++ %3c 3) {%0a%3c 			try {%0a%3c 				Thread.sleep(1000);%0a%3c 				notifyObservers();%0a%3c 			} catch (Exception e) {%0a%3c 				System.out.println(e);%0a%3c 			}%0a%3c 		}%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteObserverA.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c public class ConcreteObserverA implements Observer {%0a%3c 	public void update() {%0a%3c 		System.out.println("ConcreteObserverA got updated.");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteObserverB.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c public class ConcreteObserverB implements Observer {%0a%3c 	public void update() {%0a%3c 		System.out.println("ConcreteObserverB got updated.");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Observable.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c public interface Observable {%0a%3c 	public void addObserver(Observer o);%0a%3c 	public void deleteObserver(Observer o);%0a%3c 	public void notifyObservers();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Observer.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c public interface Observer {%0a%3c 	public void update();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Observer;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		ConcreteObservable observable = new ConcreteObservable();%0a%3c 		observable.addObserver(new ConcreteObserverA());%0a%3c 		observable.addObserver(new ConcreteObserverB());%0a%3c 		observable.demo();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319033900=117.89.207.43
