version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12
author=
charset=UTF-8
csum=
ctime=1290592183
host=194.237.142.10
name=Linux.LockSpinlocks
rev=1
targets=
text=Four points must be noted when using spinlocks:%0a%0a# If a lock is acquired but no longer released, the system is rendered unusable. All processors— including the one that acquired the lock — sooner or later arrive at a point where they must enter the critical region. They go into the endless loop to wait for lock release, but this never happens. This produces a deadlock, and the grim name suggests that it’s something that should be avoided.%0a%0a# On no account should spinlocks be acquired for a longer period because all processors waiting for lock release are no longer available for other productive tasks (the situation with semaphores is different, as you will see shortly).%0a%0a# Code that is protected by spinlocks must not go to sleep. This rule is not so simple to obey as it seems: It is not complicated to avoid going to sleep actively, but it must also be ensured that none of the functions that are called inside a spinlocked region can go to sleep! One particular example is the kmalloc function: Usually the requested memory will be returned straight away, but when the kernel is short on memory, the function can go to sleep, as discussed in Chapter 3. Code that makes the mistake of allocating memory inside a spinlocked region will thus work perfectly fine most of the time, but sometimes cause a failure. Naturally, such problems are very hard to reproduce and debug. Therefore, you should pay great attention to which functions you call inside a spinlocked region, and make sure that they cannot go to sleep in any circumstance.%0a%0a# Spinlocks cannot be acquired more than once from the current holder! This is especially important when functions that call other functions that each operate with the same lock. If a lock has already been acquired and a function is called that tries to again acquire it although the current code path is already holding the lock, a deadlock will occur — the processor will wait for itself to release the lock, and this might take a while . . .%0a%0a
time=1290592183
author:1290592183=
diff:1290592183:1290592183:=1,10d0%0a%3c Four points must be noted when using spinlocks:%0a%3c %0a%3c # If a lock is acquired but no longer released, the system is rendered unusable. All processors— including the one that acquired the lock — sooner or later arrive at a point where they must enter the critical region. They go into the endless loop to wait for lock release, but this never happens. This produces a deadlock, and the grim name suggests that it’s something that should be avoided.%0a%3c %0a%3c # On no account should spinlocks be acquired for a longer period because all processors waiting for lock release are no longer available for other productive tasks (the situation with semaphores is different, as you will see shortly).%0a%3c %0a%3c # Code that is protected by spinlocks must not go to sleep. This rule is not so simple to obey as it seems: It is not complicated to avoid going to sleep actively, but it must also be ensured that none of the functions that are called inside a spinlocked region can go to sleep! One particular example is the kmalloc function: Usually the requested memory will be returned straight away, but when the kernel is short on memory, the function can go to sleep, as discussed in Chapter 3. Code that makes the mistake of allocating memory inside a spinlocked region will thus work perfectly fine most of the time, but sometimes cause a failure. Naturally, such problems are very hard to reproduce and debug. Therefore, you should pay great attention to which functions you call inside a spinlocked region, and make sure that they cannot go to sleep in any circumstance.%0a%3c %0a%3c # Spinlocks cannot be acquired more than once from the current holder! This is especially important when functions that call other functions that each operate with the same lock. If a lock has already been acquired and a function is called that tries to again acquire it although the current code path is already holding the lock, a deadlock will occur — the processor will wait for itself to release the lock, and this might take a while . . .%0a%3c %0a
host:1290592183=194.237.142.10
