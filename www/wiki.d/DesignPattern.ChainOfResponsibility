version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319034179
host=117.89.207.43
name=DesignPattern.ChainOfResponsibility
rev=2
targets=DesignPattern.ChainOfResponsibility
text=\\%0a %0a[+++'''责任链模式/Chain Of Responsibility'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理了这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/ChainOfResponsibility/ChainOfResponsibility.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/ChainOfResponsibility/ChainOfResponsibility.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象处理者(Handler)：定义出一个处理请求和管理责任链的接口。%0a# 具体处理者(ConcreteHandler)：实现Handler的接口。它的功能是，要么把请求处理掉，要么把请求传给下家。%0a%0a[+++''扩展：''+++]%0a%0a理论上，一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：或者承担责任，或者把责任推给下家。而且每一个请求最终都会被某一个合适的处理者处理掉。%0a%0a但在实际应用中，这两个条件可能都并不满足。一个处理者可能对请求做了一些处理之后仍然把它传给下家。一个请求也可能找不到一个合适的处理者，最终没有被任何处理者所处理而被“扔掉”。%0a%0a[+++''应用实例：''+++]%0a%0a还记得早期的AWT 1.0编程吗？当处理一个窗口事件时，在事件处理方法中你必须要返回一个true或者false，AWT系统以此来决定是否继续把事件传递给其它监听者来处理。%0a%0a这就是责任链模式的一种应用。由于视窗构件往往位于容器构件内，因此当事件发生在一个构件上时，此构件的事件处理者可以处理此事件，然后决定是否将事件向上级窗口构件传播。上级窗口构件接到事件后，可以在此处理事件，或者决定是否再次将事件向更上一级窗口构件传播。如此往复，直到事件到达顶层构件。%0a%0aAWT 1.0的这种方式也暴露出此模式的一些缺点：%0a# 事件处理模式是基于继承的。所有事件处理器者继承自同一个基类，并且需要转换掉同一个事件处理方法，比如handleEvent()。继承关系的缺点在于不灵活，应该尽量地使用委派关系。过多地继承还可能导致维护成本上升。%0a# 待处理事件会沿着责任链逐级传播，如果链路较长，而且每一级的处理时间又比较长，会使得事件处理得很慢。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteHandlerA.java %0a%0apackage designPatterns.ChainOfResponsibility;%0a%0apublic class ConcreteHandlerA extends Handler {%0a	public void handleRequest(Request request) {%0a		if (request.data %3c 0)%0a			System.out.println("ConcreteHandlerA.handleRequest() as data %3c 0");%0a		else {%0a			Handler successor = getSuccessor();%0a			if (null != successor)%0a				successor.handleRequest(request);%0a		}%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteHandlerB.java %0a%0apackage designPatterns.ChainOfResponsibility;%0a%0apublic class ConcreteHandlerB extends Handler {%0a	public void handleRequest(Request request) {%0a		if (request.data >= 0)%0a			System.out.println("ConcreteHandlerB.handleRequest() as data >= 0");%0a		else {%0a			Handler successor = getSuccessor();%0a			if (null != successor)%0a				successor.handleRequest(request);%0a		}%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Handler.java %0a%0apackage designPatterns.ChainOfResponsibility;%0a%0apublic abstract class Handler {%0a	%0a	private Handler successor = null;%0a	%0a	public void setSuccessor(Handler successor) {%0a		this.successor = successor;%0a	}%0a	%0a	public Handler getSuccessor() {%0a		return successor;%0a	}%0a	%0a	public abstract void handleRequest(Request request);%0a	%0a}%0a%0a%0a// Source code from file:  Request.java %0a%0apackage designPatterns.ChainOfResponsibility;%0a%0apublic class Request {%0a	int data;%0a	public Request(int data) {%0a		this.data = data;%0a	}%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.ChainOfResponsibility;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Handler handler = new ConcreteHandlerA();%0a		handler.setSuccessor(new ConcreteHandlerB());%0a		handler.handleRequest(new Request(1));%0a	}%0a}%0a(:sourcend:)
time=1319036957
author:1319036957=
diff:1319036957:1319034179:=10,11c10%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/ChainOfResponsibility/ChainOfResponsibility.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/ChainOfResponsibility/ChainOfResponsibility.png]]%0a%3c %0a---%0a>  %0a
host:1319036957=117.89.207.43
author:1319034179=
diff:1319034179:1319034179:=1,112d0%0a%3c \\%0a%3c  %0a%3c [+++'''责任链模式/Chain Of Responsibility'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理了这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象处理者(Handler)：定义出一个处理请求和管理责任链的接口。%0a%3c # 具体处理者(ConcreteHandler)：实现Handler的接口。它的功能是，要么把请求处理掉，要么把请求传给下家。%0a%3c %0a%3c [+++''扩展：''+++]%0a%3c %0a%3c 理论上，一个纯的责任链模式要求一个具体的处理者对象只能在两个行为中选择一个：或者承担责任，或者把责任推给下家。而且每一个请求最终都会被某一个合适的处理者处理掉。%0a%3c %0a%3c 但在实际应用中，这两个条件可能都并不满足。一个处理者可能对请求做了一些处理之后仍然把它传给下家。一个请求也可能找不到一个合适的处理者，最终没有被任何处理者所处理而被“扔掉”。%0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c %0a%3c 还记得早期的AWT 1.0编程吗？当处理一个窗口事件时，在事件处理方法中你必须要返回一个true或者false，AWT系统以此来决定是否继续把事件传递给其它监听者来处理。%0a%3c %0a%3c 这就是责任链模式的一种应用。由于视窗构件往往位于容器构件内，因此当事件发生在一个构件上时，此构件的事件处理者可以处理此事件，然后决定是否将事件向上级窗口构件传播。上级窗口构件接到事件后，可以在此处理事件，或者决定是否再次将事件向更上一级窗口构件传播。如此往复，直到事件到达顶层构件。%0a%3c %0a%3c AWT 1.0的这种方式也暴露出此模式的一些缺点：%0a%3c # 事件处理模式是基于继承的。所有事件处理器者继承自同一个基类，并且需要转换掉同一个事件处理方法，比如handleEvent()。继承关系的缺点在于不灵活，应该尽量地使用委派关系。过多地继承还可能导致维护成本上升。%0a%3c # 待处理事件会沿着责任链逐级传播，如果链路较长，而且每一级的处理时间又比较长，会使得事件处理得很慢。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteHandlerA.java %0a%3c %0a%3c package designPatterns.ChainOfResponsibility;%0a%3c %0a%3c public class ConcreteHandlerA extends Handler {%0a%3c 	public void handleRequest(Request request) {%0a%3c 		if (request.data %3c 0)%0a%3c 			System.out.println("ConcreteHandlerA.handleRequest() as data %3c 0");%0a%3c 		else {%0a%3c 			Handler successor = getSuccessor();%0a%3c 			if (null != successor)%0a%3c 				successor.handleRequest(request);%0a%3c 		}%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteHandlerB.java %0a%3c %0a%3c package designPatterns.ChainOfResponsibility;%0a%3c %0a%3c public class ConcreteHandlerB extends Handler {%0a%3c 	public void handleRequest(Request request) {%0a%3c 		if (request.data >= 0)%0a%3c 			System.out.println("ConcreteHandlerB.handleRequest() as data >= 0");%0a%3c 		else {%0a%3c 			Handler successor = getSuccessor();%0a%3c 			if (null != successor)%0a%3c 				successor.handleRequest(request);%0a%3c 		}%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Handler.java %0a%3c %0a%3c package designPatterns.ChainOfResponsibility;%0a%3c %0a%3c public abstract class Handler {%0a%3c 	%0a%3c 	private Handler successor = null;%0a%3c 	%0a%3c 	public void setSuccessor(Handler successor) {%0a%3c 		this.successor = successor;%0a%3c 	}%0a%3c 	%0a%3c 	public Handler getSuccessor() {%0a%3c 		return successor;%0a%3c 	}%0a%3c 	%0a%3c 	public abstract void handleRequest(Request request);%0a%3c 	%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Request.java %0a%3c %0a%3c package designPatterns.ChainOfResponsibility;%0a%3c %0a%3c public class Request {%0a%3c 	int data;%0a%3c 	public Request(int data) {%0a%3c 		this.data = data;%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.ChainOfResponsibility;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Handler handler = new ConcreteHandlerA();%0a%3c 		handler.setSuccessor(new ConcreteHandlerB());%0a%3c 		handler.handleRequest(new Request(1));%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319034179=117.89.207.43
