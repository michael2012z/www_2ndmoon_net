version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2
author=
charset=UTF-8
csum=
ctime=1322571076
host=180.109.20.119
name=Linux.VFSMounting
rev=2
targets=Linux.VFSMounting
text=!! Mounting%0a%0aA struct vfsmount describes a mount. The definition lives in mount.h:%0a(:source lang=c:)%0astruct vfsmount {%0a	struct list_head mnt_hash;%0a	struct vfsmount *mnt_parent;	/* fs we are mounted on */%0a	struct dentry *mnt_mountpoint;	/* dentry of mountpoint */%0a	struct dentry *mnt_root;	/* root of the mounted tree */%0a	struct super_block *mnt_sb;	/* pointer to superblock */%0a#ifdef CONFIG_SMP%0a	struct mnt_pcp __percpu *mnt_pcp;%0a	atomic_t mnt_longterm;		/* how many of the refs are longterm */%0a#else%0a	int mnt_count;%0a	int mnt_writers;%0a#endif%0a	struct list_head mnt_mounts;	/* list of children, anchored here */%0a	struct list_head mnt_child;	/* and going through their mnt_child */%0a	int mnt_flags;%0a	/* 4 bytes hole on 64bits arches without fsnotify */%0a#ifdef CONFIG_FSNOTIFY%0a	__u32 mnt_fsnotify_mask;%0a	struct hlist_head mnt_fsnotify_marks;%0a#endif%0a	const char *mnt_devname;	/* Name of device e.g. /dev/dsk/hda1 */%0a	struct list_head mnt_list;%0a	struct list_head mnt_expire;	/* link in fs-specific expiry list */%0a	struct list_head mnt_share;	/* circular list of shared mounts */%0a	struct list_head mnt_slave_list;/* list of slave mounts */%0a	struct list_head mnt_slave;	/* slave list entry */%0a	struct vfsmount *mnt_master;	/* slave is on master->mnt_slave_list */%0a	struct mnt_namespace *mnt_ns;	/* containing namespace */%0a	int mnt_id;			/* mount identifier */%0a	int mnt_group_id;		/* peer group identifier */%0a	int mnt_expiry_mark;		/* true if marked for expiry */%0a	int mnt_pinned;%0a	int mnt_ghosts;%0a};%0a(:sourcend:)%0a%0aLong ago (1.3.46) it was introduced as part of the quota code. There was a linked list of struct vfsmounts that contained a device number, device name, mount point name, mount flags, superblock pointer, semaphore, file pointers to quota files and time limits for how long an over-quota situation would be allowed. Nowadays quota have independent bookkeeping, and a struct vfsmount only describes a mount.%0a%0aThese structs are allocated by alloc_vfsmnt() and released by free_vfsmnt() in namespace.c.%0a%0a!!! mnt_hash%0a%0aVfsmounts live in a hash headed by mount_hashtable[]. The field mnt_hash is the link in the collision chain. This list does not seem to be protected by a lock. They are put into the hash by attach_mnt(), found there by lookup_mnt(), and removed again by detach_mnt(), all from namespace.c.%0a%0a!!! mnt_parent%0a%0aVfsmount for parent.%0a%0a!!! mnt_mountpoint%0a%0aDentry for the mountpoint. The pair (mnt_mountpoint, mnt_parent) (returned by follow_up()) will be the dentry and vfsmount for the parent. Used e.g. in d_path to return the pathname of a dentry.%0a%0a!!! mnt_root%0a%0aDentry for the root of the mounted tree.%0a%0a!!! mnt_sb%0a%0aSuperblock of the mounted filesystem.%0a%0a!!! mnt_mounts, mnt_child%0a%0aThe field mnt_mounts of a struct vfsmount is the head of a cyclic list of all submounts (mounts on top of some path relative to the present mount). The remaining links of this cyclic list are stored in the mnt_child fields of its submounting vfsmounts. (And each of these points back at us with its mnt_parent field.) Used in autofs4/expire.c and namespace.c (and nowhere else).%0a%0a!!! mnt_count%0a%0aKeep track of users of this structure. Incremented by mntget, decremented by mntput. Initially 1. It will be 2 for a mount that may be unmounted. (Autofs also uses this to test whether a tree is busy.)%0a%0a!!! mnt_flags%0a%0aThe mount flags, like MNT_NODEV, MNT_NOEXEC, MNT_NOSUID. Earlier also MS_RDONLY (that now is stored in sb->s_flags) and MNT_VISIBLE (came in 2.4.0-test5, went in 2.4.5) that told whether this entry should be visible in /proc/mounts.%0a%0a!!! mnt_devname%0a%0aName used in /proc/mounts.%0a%0a!!! mnt_list%0a%0aThere was a global cyclic list vfsmntlist containing all mounts, used only to create the contents of /proc/mounts. These days we have per-process namespaces, and the global vfsmntlist has been replaced by current->namespace->list. This list is ordered by the order in which the mounts were done, so that one can do the umounts in reverse order. The field mnt_list contains the pointers for this cyclic list.%0a
time=1322571109
author:1322571109=
diff:1322571109:1322571076:=50c50%0a%3c !!! mnt_parent%0a---%0a> mnt_parent%0a
host:1322571109=180.109.20.119
author:1322571076=
diff:1322571076:1322571076:=1,84d0%0a%3c !! Mounting%0a%3c %0a%3c A struct vfsmount describes a mount. The definition lives in mount.h:%0a%3c (:source lang=c:)%0a%3c struct vfsmount {%0a%3c 	struct list_head mnt_hash;%0a%3c 	struct vfsmount *mnt_parent;	/* fs we are mounted on */%0a%3c 	struct dentry *mnt_mountpoint;	/* dentry of mountpoint */%0a%3c 	struct dentry *mnt_root;	/* root of the mounted tree */%0a%3c 	struct super_block *mnt_sb;	/* pointer to superblock */%0a%3c #ifdef CONFIG_SMP%0a%3c 	struct mnt_pcp __percpu *mnt_pcp;%0a%3c 	atomic_t mnt_longterm;		/* how many of the refs are longterm */%0a%3c #else%0a%3c 	int mnt_count;%0a%3c 	int mnt_writers;%0a%3c #endif%0a%3c 	struct list_head mnt_mounts;	/* list of children, anchored here */%0a%3c 	struct list_head mnt_child;	/* and going through their mnt_child */%0a%3c 	int mnt_flags;%0a%3c 	/* 4 bytes hole on 64bits arches without fsnotify */%0a%3c #ifdef CONFIG_FSNOTIFY%0a%3c 	__u32 mnt_fsnotify_mask;%0a%3c 	struct hlist_head mnt_fsnotify_marks;%0a%3c #endif%0a%3c 	const char *mnt_devname;	/* Name of device e.g. /dev/dsk/hda1 */%0a%3c 	struct list_head mnt_list;%0a%3c 	struct list_head mnt_expire;	/* link in fs-specific expiry list */%0a%3c 	struct list_head mnt_share;	/* circular list of shared mounts */%0a%3c 	struct list_head mnt_slave_list;/* list of slave mounts */%0a%3c 	struct list_head mnt_slave;	/* slave list entry */%0a%3c 	struct vfsmount *mnt_master;	/* slave is on master->mnt_slave_list */%0a%3c 	struct mnt_namespace *mnt_ns;	/* containing namespace */%0a%3c 	int mnt_id;			/* mount identifier */%0a%3c 	int mnt_group_id;		/* peer group identifier */%0a%3c 	int mnt_expiry_mark;		/* true if marked for expiry */%0a%3c 	int mnt_pinned;%0a%3c 	int mnt_ghosts;%0a%3c };%0a%3c (:sourcend:)%0a%3c %0a%3c Long ago (1.3.46) it was introduced as part of the quota code. There was a linked list of struct vfsmounts that contained a device number, device name, mount point name, mount flags, superblock pointer, semaphore, file pointers to quota files and time limits for how long an over-quota situation would be allowed. Nowadays quota have independent bookkeeping, and a struct vfsmount only describes a mount.%0a%3c %0a%3c These structs are allocated by alloc_vfsmnt() and released by free_vfsmnt() in namespace.c.%0a%3c %0a%3c !!! mnt_hash%0a%3c %0a%3c Vfsmounts live in a hash headed by mount_hashtable[]. The field mnt_hash is the link in the collision chain. This list does not seem to be protected by a lock. They are put into the hash by attach_mnt(), found there by lookup_mnt(), and removed again by detach_mnt(), all from namespace.c.%0a%3c %0a%3c mnt_parent%0a%3c %0a%3c Vfsmount for parent.%0a%3c %0a%3c !!! mnt_mountpoint%0a%3c %0a%3c Dentry for the mountpoint. The pair (mnt_mountpoint, mnt_parent) (returned by follow_up()) will be the dentry and vfsmount for the parent. Used e.g. in d_path to return the pathname of a dentry.%0a%3c %0a%3c !!! mnt_root%0a%3c %0a%3c Dentry for the root of the mounted tree.%0a%3c %0a%3c !!! mnt_sb%0a%3c %0a%3c Superblock of the mounted filesystem.%0a%3c %0a%3c !!! mnt_mounts, mnt_child%0a%3c %0a%3c The field mnt_mounts of a struct vfsmount is the head of a cyclic list of all submounts (mounts on top of some path relative to the present mount). The remaining links of this cyclic list are stored in the mnt_child fields of its submounting vfsmounts. (And each of these points back at us with its mnt_parent field.) Used in autofs4/expire.c and namespace.c (and nowhere else).%0a%3c %0a%3c !!! mnt_count%0a%3c %0a%3c Keep track of users of this structure. Incremented by mntget, decremented by mntput. Initially 1. It will be 2 for a mount that may be unmounted. (Autofs also uses this to test whether a tree is busy.)%0a%3c %0a%3c !!! mnt_flags%0a%3c %0a%3c The mount flags, like MNT_NODEV, MNT_NOEXEC, MNT_NOSUID. Earlier also MS_RDONLY (that now is stored in sb->s_flags) and MNT_VISIBLE (came in 2.4.0-test5, went in 2.4.5) that told whether this entry should be visible in /proc/mounts.%0a%3c %0a%3c !!! mnt_devname%0a%3c %0a%3c Name used in /proc/mounts.%0a%3c %0a%3c !!! mnt_list%0a%3c %0a%3c There was a global cyclic list vfsmntlist containing all mounts, used only to create the contents of /proc/mounts. These days we have per-process namespaces, and the global vfsmntlist has been replaced by current->namespace->list. This list is ordered by the order in which the mounts were done, so that one can do the umounts in reverse order. The field mnt_list contains the pointers for this cyclic list.%0a
host:1322571076=180.109.20.119
