version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.41 Safari/534.7
author=
charset=UTF-8
csum=
ctime=1288611597
host=112.3.235.49
name=Linux.MmBuddyFragmentation
rev=5
targets=
text=!! Fragmentation%0a%0aAn extreme example:%0a%0a%25width=560 newwin%25 [[Attach:mm_budfragment.png | Attach:mm_budfragment.png]]%0a%0aAssume that the memory consists of 60 pages — clearly, this is not going to be the key component to the next supercomputer, but is fair enough for the sake of example. The free pages are scattered across the address space on the left-hand side. Although roughly 25 percent of the physical memory is still unallocated, the largest continuous free area is only a single page. This is no problem for userspace applications: Since their memory is mapped over page tables, it will always appear continuous to them irrespective of how the free pages are distributed in physical memory. The right-hand side shows the situation with the same number of used and free pages, but with all free pages located in a continuous area.%0a%0aYet another example:%0a%0a%25width=560 newwin%25 [[Attach:mm_budfragment1.png | Attach:mm_budfragment1.png]]%0a%0aInterestingly, problems with fragmentation can already occur when most of the memory is still unallocated. Consider the situation in Figure 3-25. Only 4 pages are reserved, but the largest contiguous area that can be allocated is 8 pages because the buddy system can only work that allocation ranges that are powers of 2.%0a%0a----%0a!! Avoid Fragmentation%0a%0aFragmentation of physical memory has, indeed, belonged to the weaker points of Linux for an unusually long time span. Although many approaches have been suggested, none could satisfy the demanding needs of the numerous workloads that Linux has to face without having too great an impact on others. During the development of kernel 2.6.24, means to prevent fragmentation finally found their way into the kernel. Before I discuss their strategy, one point calls for clarification: Fragmentation is also known from filesystems, and in this area the problem is typically solved by defragmentation tools: They analyze the filesystem and rearrange the allocated blocks such that larger continuous areas arise. This approach would also be possible for RAM, in principle, but is complicated by the fact that many physical pages cannot be moved to an arbitrary location. Therefore, the kernel’s approach is anti-fragmentation: Try to prevent fragmentation as well as possible from the very beginning.%0a%0aHow does anti-fragmentation work? To understand the approach, we must be aware that the kernel distinguishes three different types of reserved pages:%0a%0a❑ Non-movable pages have a fixed position in memory and cannot be moved anywhere else. Most allocations of the core kernel fall into this category.\\%0a❑ Reclaimable pages cannot be moved directly, but they can be deleted and their contents regenerated from some source. Data mapped from files fall into this category, for instance. \\%0aReclaimable pages are periodically freed by the kswapd daemon depending on how often they are accessed. This is a complicated process that merits a detailed discussion of its own: Chapter 18 that describes page reclaim in detail. In the meanwhile, it suffices to know that the kernel will take care of removing reclaimable pages when they start to use up too much RAM. \\%0aIt is also possible to initiate page reclaim when there is an acute shortage of memory, that is, when an allocation has failed. You will see further below when the kernel deems it necessary to do so.\\%0a❑ Movable pages can be moved around as desired. Pages that belong to userspace applications fall into this category. They are mapped via page tables. If they are copied into a new location, the page table entries can be updated accordingly, and the application won’t notice anything.%0a%0aA page has a certain mobility depending into which of the three categories it falls. The anti-fragmentation technique used by the kernel is based on the idea of grouping pages with identical mobility together. Why does this approach help to reduce fragmentation? Recall from Figure 3-25 that a page that cannot be moved somewhere else can prevent continuous allocations in an otherwise nearly completely empty RAM area. By distributing pages onto different lists depending on their mobility, this situation is prevented.%0a%0aFor instance, a non-movable page cannot be located in the middle of a block of movable pages and effectively prevent any larger part of the block from being used.%0a%0a----%0a%0a!! Data Structure%0a%0a%25width=560 newwin%25 [[Attach:mm_budfreearea3.png | Attach:mm_budfreearea3.png]]%0a%0aThe types MIGRATE_UNMOVABLE, MIGRATE_RECLAIMABLE, and MIGRATE_MOVABLE have already been introduced. MIGRATE_RESERVE provides an emergency memory reserve if an allocation request cannot be fulfilled from the mobility-specific lists (it is filled during initialization of the memory subsystem with setup_zone_migrate_reserve, but I will not go into detail about this). MIGRATE_ISOLATE is a special virtual zone that is required to move physical pages across NUMA nodes. On large systems, it can be beneficial to bring physical pages closer to the CPUs that use them most. MIGRATE_TYPES, finally, is also not a zone, but just denotes the number of migrate types.%0a%0aWhat happens if the kernel cannot fulfill an allocation request for a given migrate type? A similar problem has already occurred before, namely, when we considered what happens when an allocation cannot be fulfilled from a specific NUMA zone. The kernel proceeds similarly as in this case by providing a fallback list regulating which migrate types should be used next if a request cannot be fulfilled from the desired list:%0a%0a%25width=560 newwin%25 [[Attach:mm_budmigratefallback.png | Attach:mm_budmigratefallback.png]]%0a%0a
time=1288621425
author:1288621425=
diff:1288621425:1288621399:=34c34%0a%3c !! Data Structure%0a---%0a> Data Structure%0a
host:1288621425=112.3.235.49
author:1288621399=
diff:1288621399:1288620631:=28,43c28%0a%3c A page has a certain mobility depending into which of the three categories it falls. The anti-fragmentation technique used by the kernel is based on the idea of grouping pages with identical mobility together. Why does this approach help to reduce fragmentation? Recall from Figure 3-25 that a page that cannot be moved somewhere else can prevent continuous allocations in an otherwise nearly completely empty RAM area. By distributing pages onto different lists depending on their mobility, this situation is prevented.%0a%3c %0a%3c For instance, a non-movable page cannot be located in the middle of a block of movable pages and effectively prevent any larger part of the block from being used.%0a%3c %0a%3c ----%0a%3c %0a%3c Data Structure%0a%3c %0a%3c %25width=560 newwin%25 [[Attach:mm_budfreearea3.png | Attach:mm_budfreearea3.png]]%0a%3c %0a%3c The types MIGRATE_UNMOVABLE, MIGRATE_RECLAIMABLE, and MIGRATE_MOVABLE have already been introduced. MIGRATE_RESERVE provides an emergency memory reserve if an allocation request cannot be fulfilled from the mobility-specific lists (it is filled during initialization of the memory subsystem with setup_zone_migrate_reserve, but I will not go into detail about this). MIGRATE_ISOLATE is a special virtual zone that is required to move physical pages across NUMA nodes. On large systems, it can be beneficial to bring physical pages closer to the CPUs that use them most. MIGRATE_TYPES, finally, is also not a zone, but just denotes the number of migrate types.%0a%3c %0a%3c What happens if the kernel cannot fulfill an allocation request for a given migrate type? A similar problem has already occurred before, namely, when we considered what happens when an allocation cannot be fulfilled from a specific NUMA zone. The kernel proceeds similarly as in this case by providing a fallback list regulating which migrate types should be used next if a request cannot be fulfilled from the desired list:%0a%3c %0a%3c %25width=560 newwin%25 [[Attach:mm_budmigratefallback.png | Attach:mm_budmigratefallback.png]]%0a%3c %0a---%0a> A page has a certain mobility depending into which of the three categories it falls.%0a\ No newline at end of file%0a
host:1288621399=112.3.235.49
author:1288620631=
diff:1288620631:1288611749:=1,2c1,2%0a%3c !! Fragmentation%0a%3c %0a---%0a> !! Avoid Fragmentation%0a> %0a13,28c13%0a%3c Interestingly, problems with fragmentation can already occur when most of the memory is still unallocated. Consider the situation in Figure 3-25. Only 4 pages are reserved, but the largest contiguous area that can be allocated is 8 pages because the buddy system can only work that allocation ranges that are powers of 2.%0a%3c %0a%3c ----%0a%3c !! Avoid Fragmentation%0a%3c %0a%3c Fragmentation of physical memory has, indeed, belonged to the weaker points of Linux for an unusually long time span. Although many approaches have been suggested, none could satisfy the demanding needs of the numerous workloads that Linux has to face without having too great an impact on others. During the development of kernel 2.6.24, means to prevent fragmentation finally found their way into the kernel. Before I discuss their strategy, one point calls for clarification: Fragmentation is also known from filesystems, and in this area the problem is typically solved by defragmentation tools: They analyze the filesystem and rearrange the allocated blocks such that larger continuous areas arise. This approach would also be possible for RAM, in principle, but is complicated by the fact that many physical pages cannot be moved to an arbitrary location. Therefore, the kernel’s approach is anti-fragmentation: Try to prevent fragmentation as well as possible from the very beginning.%0a%3c %0a%3c How does anti-fragmentation work? To understand the approach, we must be aware that the kernel distinguishes three different types of reserved pages:%0a%3c %0a%3c ❑ Non-movable pages have a fixed position in memory and cannot be moved anywhere else. Most allocations of the core kernel fall into this category.\\%0a%3c ❑ Reclaimable pages cannot be moved directly, but they can be deleted and their contents regenerated from some source. Data mapped from files fall into this category, for instance. \\%0a%3c Reclaimable pages are periodically freed by the kswapd daemon depending on how often they are accessed. This is a complicated process that merits a detailed discussion of its own: Chapter 18 that describes page reclaim in detail. In the meanwhile, it suffices to know that the kernel will take care of removing reclaimable pages when they start to use up too much RAM. \\%0a%3c It is also possible to initiate page reclaim when there is an acute shortage of memory, that is, when an allocation has failed. You will see further below when the kernel deems it necessary to do so.\\%0a%3c ❑ Movable pages can be moved around as desired. Pages that belong to userspace applications fall into this category. They are mapped via page tables. If they are copied into a new location, the page table entries can be updated accordingly, and the application won’t notice anything.%0a%3c %0a%3c A page has a certain mobility depending into which of the three categories it falls.%0a\ No newline at end of file%0a---%0a> Interestingly, problems with fragmentation can already occur when most of the memory is still unallocated. Consider the situation in Figure 3-25. Only 4 pages are reserved, but the largest contiguous area that can be allocated is 8 pages because the buddy system can only work that allocation ranges that are powers of 2.%0a\ No newline at end of file%0a
host:1288620631=112.3.235.49
author:1288611749=
diff:1288611749:1288611597:=9,13d8%0a%3c Yet another example:%0a%3c %0a%3c %25width=560 newwin%25 [[Attach:mm_budfragment1.png | Attach:mm_budfragment1.png]]%0a%3c %0a%3c Interestingly, problems with fragmentation can already occur when most of the memory is still unallocated. Consider the situation in Figure 3-25. Only 4 pages are reserved, but the largest contiguous area that can be allocated is 8 pages because the buddy system can only work that allocation ranges that are powers of 2.%0a\ No newline at end of file%0a
host:1288611749=112.3.235.49
author:1288611597=
diff:1288611597:1288611597:=1,8d0%0a%3c !! Avoid Fragmentation%0a%3c %0a%3c An extreme example:%0a%3c %0a%3c %25width=560 newwin%25 [[Attach:mm_budfragment.png | Attach:mm_budfragment.png]]%0a%3c %0a%3c Assume that the memory consists of 60 pages — clearly, this is not going to be the key component to the next supercomputer, but is fair enough for the sake of example. The free pages are scattered across the address space on the left-hand side. Although roughly 25 percent of the physical memory is still unallocated, the largest continuous free area is only a single page. This is no problem for userspace applications: Since their memory is mapped over page tables, it will always appear continuous to them irrespective of how the free pages are distributed in physical memory. The right-hand side shows the situation with the same number of used and free pages, but with all free pages located in a continuous area.%0a%3c %0a
host:1288611597=112.3.235.49
