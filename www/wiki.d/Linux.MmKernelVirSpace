version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.41 Safari/534.7
author=
charset=UTF-8
csum=
ctime=1288516636
host=112.2.92.173
name=Linux.MmKernelVirSpace
rev=4
targets=
text=!! Kernel Virtual Address Space%0a%0a%25width=560 newwin%25 [[Attach:mm_kernelvirspace.png | Attach:mm_kernelvirspace.png]]%0a%0aThere are 6 partition (from left to right) in this figure:%0a%0a# The first section of the address space is used to map all physical pages of the system into the virtual address space of the kernel. Because this address space begins at an offset of 0xC0000000 — the frequently mentioned 3 GiB — each virtual address x corresponds to the physical address x - 0xC0000000, and is therefore a simple linear shift.\\%0aAs the figure shows, the direct mapping area extends from 0xC0000000 to the high_memory address whose exact value I discuss shortly. As intimated in Chapter 1, there is a problem with this scheme. Because the virtual address space of the kernel comprises only 1 GiB, a maximum of 1 GiB of RAM memory can be mapped. The fact that the maximum memory configuration on IA-32 systems (without PAE) can be up to 4 GiB raises the question of what to do with the remaining memory.%0a# This gap acts as a safeguard against any kernel faults. If out of bound addresses are accessed (these are unintentional accesses to memory areas that are no longer physically present), access fails and an exception is generated to report the error. If the vmalloc area were to immediately follow the direct mappings, access would be successful and the error would not be noticed. There should be no need for this additional safeguard in stable operation, but it is useful when developing new kernel features that are not yet mature.%0a# Virtually contiguous memory areas that are not contiguous in physical memory can be reserved in the vmalloc area. While this mechanism is commonly used with user processes, the kernel itself tries to avoid non-contiguous physical addresses as best it can. It usually succeeds because most of the large memory blocks are allocated for the kernel at boot time when RAM is not yet fragmented. However, on systems that have been running for longer periods, situations can arise in which the kernel requires physical memory but the space available is not contiguous. A prime example of such a situation is when modules are loaded dynamically.%0a# Where the vmalloc area ends depends on whether highmem support is enabled — if it is not, no space is needed for persistent kernel mappings because the whole of RAM memory can be permanently mapped. Depending on configuration, the area therefore ends either at the start of the persistent kernel mappings or at the start of the fixmap area; two pages are always left as a safety gap to the vmalloc area.%0a# Persistent mappings are used to map non-persistent pages from the highmem area into the kernel. Section 3.5.8 takes a close look at this topic.%0a# Fixmaps are virtual address space entries associated with a fixed but freely selectable page in physical address space. In contrast to directly mapped pages that are associated with RAM memory by means of a fixed formula, the association between a virtual fixmap address and the position in RAM memory can be freely defined and is then always observed by the kernel.%0a
time=1288517386
author:1288517386=
diff:1288517386:1288517341:=5c5%0a%3c There are 6 partition (from left to right) in this figure:%0a---%0a> There are 6 partition in this figure:%0a
host:1288517386=112.2.92.173
author:1288517341=
diff:1288517341:1288517108:=9d8%0a%3c # This gap acts as a safeguard against any kernel faults. If out of bound addresses are accessed (these are unintentional accesses to memory areas that are no longer physically present), access fails and an exception is generated to report the error. If the vmalloc area were to immediately follow the direct mappings, access would be successful and the error would not be noticed. There should be no need for this additional safeguard in stable operation, but it is useful when developing new kernel features that are not yet mature.%0a11d9%0a%3c # Where the vmalloc area ends depends on whether highmem support is enabled — if it is not, no space is needed for persistent kernel mappings because the whole of RAM memory can be permanently mapped. Depending on configuration, the area therefore ends either at the start of the persistent kernel mappings or at the start of the fixmap area; two pages are always left as a safety gap to the vmalloc area.%0a13c11%0a%3c # Fixmaps are virtual address space entries associated with a fixed but freely selectable page in physical address space. In contrast to directly mapped pages that are associated with RAM memory by means of a fixed formula, the association between a virtual fixmap address and the position in RAM memory can be freely defined and is then always observed by the kernel.%0a---%0a> #%0a\ No newline at end of file%0a
host:1288517341=112.2.92.173
author:1288517108=
diff:1288517108:1288516636:=4,11d3%0a%3c %0a%3c There are 6 partition in this figure:%0a%3c %0a%3c # The first section of the address space is used to map all physical pages of the system into the virtual address space of the kernel. Because this address space begins at an offset of 0xC0000000 — the frequently mentioned 3 GiB — each virtual address x corresponds to the physical address x - 0xC0000000, and is therefore a simple linear shift.\\%0a%3c As the figure shows, the direct mapping area extends from 0xC0000000 to the high_memory address whose exact value I discuss shortly. As intimated in Chapter 1, there is a problem with this scheme. Because the virtual address space of the kernel comprises only 1 GiB, a maximum of 1 GiB of RAM memory can be mapped. The fact that the maximum memory configuration on IA-32 systems (without PAE) can be up to 4 GiB raises the question of what to do with the remaining memory.%0a%3c # Virtually contiguous memory areas that are not contiguous in physical memory can be reserved in the vmalloc area. While this mechanism is commonly used with user processes, the kernel itself tries to avoid non-contiguous physical addresses as best it can. It usually succeeds because most of the large memory blocks are allocated for the kernel at boot time when RAM is not yet fragmented. However, on systems that have been running for longer periods, situations can arise in which the kernel requires physical memory but the space available is not contiguous. A prime example of such a situation is when modules are loaded dynamically.%0a%3c # Persistent mappings are used to map non-persistent pages from the highmem area into the kernel. Section 3.5.8 takes a close look at this topic.%0a%3c # %0a\ No newline at end of file%0a
host:1288517108=112.2.92.173
author:1288516636=
diff:1288516636:1288516636:=1,3d0%0a%3c !! Kernel Virtual Address Space%0a%3c %0a%3c %25width=560 newwin%25 [[Attach:mm_kernelvirspace.png | Attach:mm_kernelvirspace.png]]%0a
host:1288516636=112.2.92.173
