version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319035574
host=117.89.207.43
name=DesignPattern.State
rev=3
targets=DesignPattern.State
text=\\%0a %0a[+++'''状态模式/State'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a状态模式允许一个对象在其内部状态改变的时候改变其行为，这个对象看上去就像是改变了它的类一样。\\%0a在两种情况下均可以使用状态模式:%0a# 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。%0a# 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。状态模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个新的对象，这一新的对象可以不依赖于同类的其他对象而独立变化。%0a%0a状态模式有下面一些效果:%0a# 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。%0a# 它使得状态转换显式化。%0a# 状态对象可被共享。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/State/State.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/State/State.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象状态(State)：状态类的接口，封装了环境对象的一个特定状态所对应的行为。%0a# 具体状态(ConcreteState)：实现某一状态所对应的行为。%0a# 环境(Context)：保留状态类的实例，依当前所处的状态不同而更换这个实例，实现不同的行为。%0a%0a[+++''要点：''+++]%0a%0a什么时候创建和销毁State对象是一个值得考虑问题。有两种选择：%0a# 仅当需要State对象时才创建它们并随后销毁它们。%0a# 提前创建它们并且始终不销毁它们。%0a应根据State对象的数量、每一个State对象的创建成本以及系统的要求来选择。%0a%0a[+++''应用实例：''+++]%0a%0a考虑一个表示网络连接的类TCPConnection。一个TCPConnection对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听(Listening)、连接已关闭(Closed)。当一个TCPConnection对象收到其他对象的请求时,它根据自身的当前状态作出不同的反应。例如，一个Open请求的结果依赖于该连接是处于连接已关闭状态还是连接已建立状态。\\%0aState模式描述了TCPConnection如何在每一种状态下表现出不同的行为。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteStateA.java %0a%0apackage designPatterns.State;%0a%0apublic class ConcreteStateA implements State {%0a	public void operation() {%0a		System.out.println("ConcreteStateA.operation()");%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteStateB.java %0a%0apackage designPatterns.State;%0a%0apublic class ConcreteStateB implements State {%0a	public void operation() {%0a		System.out.println("ConcreteStateB.operation()");%0a	}%0a}%0a%0a%0a// Source code from file:  Context.java %0a%0apackage designPatterns.State;%0a%0apublic class Context {%0a	private State state = null;%0a	private State stateA = null;%0a	private State stateB = null;%0a	%0a	public Context() {%0a		stateA = new ConcreteStateA();%0a		stateB = new ConcreteStateB();%0a		state = stateA;%0a	}%0a	%0a	public void switchState() {%0a		if (state == stateA)%0a			state = stateB;%0a		else%0a			state = stateA;%0a	}%0a	%0a	public void operation() {%0a		state.operation();%0a	}%0a	%0a}%0a%0a%0a// Source code from file:  State.java %0a%0apackage designPatterns.State;%0a%0apublic interface State {%0a	public void operation();%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.State;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Context c = new Context();%0a		c.operation();%0a		c.switchState();%0a		c.operation();%0a		c.switchState();%0a		c.operation();%0a	}%0a}%0a(:sourcend:)
time=1319037045
author:1319037045=
diff:1319037045:1319035603:=18,19c18%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/State/State.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/State/State.png]]%0a%3c %0a---%0a>  %0a
host:1319037045=117.89.207.43
author:1319035603=
diff:1319035603:1319035574:=5,6c5%0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a---%0a> [+++''意图/适用场景：''+++]\\%0a24,25c23%0a%3c [+++''要点：''+++]%0a%3c %0a---%0a> [+++''要点：''+++]\\%0a31,32c29%0a%3c [+++''应用实例：''+++]%0a%3c %0a---%0a> [+++''应用实例：''+++]\\%0a
host:1319035603=117.89.207.43
author:1319035574=
diff:1319035574:1319035574:=1,109d0%0a%3c \\%0a%3c  %0a%3c [+++'''状态模式/State'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]\\%0a%3c 状态模式允许一个对象在其内部状态改变的时候改变其行为，这个对象看上去就像是改变了它的类一样。\\%0a%3c 在两种情况下均可以使用状态模式:%0a%3c # 一个对象的行为取决于它的状态, 并且它必须在运行时刻根据状态改变它的行为。%0a%3c # 一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。状态模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个新的对象，这一新的对象可以不依赖于同类的其他对象而独立变化。%0a%3c %0a%3c 状态模式有下面一些效果:%0a%3c # 它将与特定状态相关的行为局部化，并且将不同状态的行为分割开来。%0a%3c # 它使得状态转换显式化。%0a%3c # 状态对象可被共享。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象状态(State)：状态类的接口，封装了环境对象的一个特定状态所对应的行为。%0a%3c # 具体状态(ConcreteState)：实现某一状态所对应的行为。%0a%3c # 环境(Context)：保留状态类的实例，依当前所处的状态不同而更换这个实例，实现不同的行为。%0a%3c %0a%3c [+++''要点：''+++]\\%0a%3c 什么时候创建和销毁State对象是一个值得考虑问题。有两种选择：%0a%3c # 仅当需要State对象时才创建它们并随后销毁它们。%0a%3c # 提前创建它们并且始终不销毁它们。%0a%3c 应根据State对象的数量、每一个State对象的创建成本以及系统的要求来选择。%0a%3c %0a%3c [+++''应用实例：''+++]\\%0a%3c 考虑一个表示网络连接的类TCPConnection。一个TCPConnection对象的状态处于若干不同状态之一：连接已建立（Established）、正在监听(Listening)、连接已关闭(Closed)。当一个TCPConnection对象收到其他对象的请求时,它根据自身的当前状态作出不同的反应。例如，一个Open请求的结果依赖于该连接是处于连接已关闭状态还是连接已建立状态。\\%0a%3c State模式描述了TCPConnection如何在每一种状态下表现出不同的行为。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteStateA.java %0a%3c %0a%3c package designPatterns.State;%0a%3c %0a%3c public class ConcreteStateA implements State {%0a%3c 	public void operation() {%0a%3c 		System.out.println("ConcreteStateA.operation()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteStateB.java %0a%3c %0a%3c package designPatterns.State;%0a%3c %0a%3c public class ConcreteStateB implements State {%0a%3c 	public void operation() {%0a%3c 		System.out.println("ConcreteStateB.operation()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Context.java %0a%3c %0a%3c package designPatterns.State;%0a%3c %0a%3c public class Context {%0a%3c 	private State state = null;%0a%3c 	private State stateA = null;%0a%3c 	private State stateB = null;%0a%3c 	%0a%3c 	public Context() {%0a%3c 		stateA = new ConcreteStateA();%0a%3c 		stateB = new ConcreteStateB();%0a%3c 		state = stateA;%0a%3c 	}%0a%3c 	%0a%3c 	public void switchState() {%0a%3c 		if (state == stateA)%0a%3c 			state = stateB;%0a%3c 		else%0a%3c 			state = stateA;%0a%3c 	}%0a%3c 	%0a%3c 	public void operation() {%0a%3c 		state.operation();%0a%3c 	}%0a%3c 	%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  State.java %0a%3c %0a%3c package designPatterns.State;%0a%3c %0a%3c public interface State {%0a%3c 	public void operation();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.State;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Context c = new Context();%0a%3c 		c.operation();%0a%3c 		c.switchState();%0a%3c 		c.operation();%0a%3c 		c.switchState();%0a%3c 		c.operation();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319035574=117.89.207.43
