version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319032730
host=117.89.207.43
name=DesignPattern.Proxy
rev=2
targets=DesignPattern.Proxy
text=\\%0a%0a[+++'''代理模式/Proxy'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a在某些情况下，一个客户不想或者不能够直接引用一个对象，这时可以通过一个“代理”来达到目的。代理对象可以在客户端与目标对象之间起到中介的作用。%0a%0a对于“墙”内的中国人来说，恐怕“代理”的概念更容易理解。有些国外网站我们在国内无法直接访问，因为GFW“帮”我们过屏蔽了这些网站。如果仍然需要访问的话，就需要设置海外代理（这个方法现在多半不管用了）。代理是我们能够访问到的服务器，而且它能够访问到那些目标网站，就让我们的电脑把访问请求发给这个代理，由代理转发给目标网站；从目标网站回来的数据也是先到达代理，代理把数据转发给我们。对于我们来说，只需要认为“代理”就是目标网站就行了。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Proxy/Proxy.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Proxy/Proxy.png]]%0a%0a[+++''参与者：''+++]%0a# Subject: 目标对象与代理对象的公共接口。任何使用目标对象的地方也都可以使用代理对象。%0a# RealSubject: 目标对象，真正的功能实体。%0a# ProxySubject: 代理。它提供与目标对象相同的接口，所有使用目标对象的地主也可以换成代理。客户端只与代理发生联系，对目标的访问都经由代理来间接地进行。当然在这个传递的过程中，代理可以添加一些自己的动作。%0a%0a[+++''相关模式：''+++]%0a%0a代理模式与下面几种模式容易混淆。%0a# 适配器模式：%0a** 在适配器模式中，“适配器”角色也位于客户端与目标角色中间，成为一个过渡性的接口。但它的作用在于改变目标角色的接口。%0a** 而代理模式并不想要改变接口，而是增加一次“传递”。%0a# 装饰模式：%0a** 代理模式与装饰模式也有相似的类结构，但装饰模式的用意在于为目标角色提供更多的功能。%0a** 而代理模式并不想追求功能的扩展（虽然也可以增加一些功能），只是目标角色的功能以间接的方式实现。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ProxySubject.java %0a%0apackage designPatterns.Proxy;%0a%0apublic class ProxySubject implements Subject {%0a	private RealSubject realSubject = null;%0a	%0a	public ProxySubject() {%0a		realSubject = new RealSubject();%0a	}%0a	%0a	public void request() {%0a		System.out.println("ProxySubject.request()");%0a		preRequest();%0a		realSubject.request();%0a		postRequest();%0a	}%0a	%0a	public void preRequest() {%0a		System.out.println("ProxySubject.preRequest()");%0a	}%0a	%0a	public void postRequest() {%0a		System.out.println("ProxySubject.postRequest()");%0a	}%0a}%0a%0a%0a// Source code from file:  RealSubject.java %0a%0apackage designPatterns.Proxy;%0a%0apublic class RealSubject implements Subject {%0a	public void request() {%0a		System.out.println("RealSubject.request()");%0a	}%0a}%0a%0a%0a// Source code from file:  Subject.java %0a%0apackage designPatterns.Proxy;%0a%0apublic interface Subject {%0a	public void request();%0a}%0a(:sourcend:)
time=1319036481
author:1319036481=
diff:1319036481:1319032730:=12,13c12%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Proxy/Proxy.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Proxy/Proxy.png]]%0a%3c %0a---%0a>  %0a
host:1319036481=117.89.207.43
author:1319032730=
diff:1319032730:1319032730:=1,76d0%0a%3c \\%0a%3c %0a%3c [+++'''代理模式/Proxy'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 在某些情况下，一个客户不想或者不能够直接引用一个对象，这时可以通过一个“代理”来达到目的。代理对象可以在客户端与目标对象之间起到中介的作用。%0a%3c %0a%3c 对于“墙”内的中国人来说，恐怕“代理”的概念更容易理解。有些国外网站我们在国内无法直接访问，因为GFW“帮”我们过屏蔽了这些网站。如果仍然需要访问的话，就需要设置海外代理（这个方法现在多半不管用了）。代理是我们能够访问到的服务器，而且它能够访问到那些目标网站，就让我们的电脑把访问请求发给这个代理，由代理转发给目标网站；从目标网站回来的数据也是先到达代理，代理把数据转发给我们。对于我们来说，只需要认为“代理”就是目标网站就行了。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # Subject: 目标对象与代理对象的公共接口。任何使用目标对象的地方也都可以使用代理对象。%0a%3c # RealSubject: 目标对象，真正的功能实体。%0a%3c # ProxySubject: 代理。它提供与目标对象相同的接口，所有使用目标对象的地主也可以换成代理。客户端只与代理发生联系，对目标的访问都经由代理来间接地进行。当然在这个传递的过程中，代理可以添加一些自己的动作。%0a%3c %0a%3c [+++''相关模式：''+++]%0a%3c %0a%3c 代理模式与下面几种模式容易混淆。%0a%3c # 适配器模式：%0a%3c ** 在适配器模式中，“适配器”角色也位于客户端与目标角色中间，成为一个过渡性的接口。但它的作用在于改变目标角色的接口。%0a%3c ** 而代理模式并不想要改变接口，而是增加一次“传递”。%0a%3c # 装饰模式：%0a%3c ** 代理模式与装饰模式也有相似的类结构，但装饰模式的用意在于为目标角色提供更多的功能。%0a%3c ** 而代理模式并不想追求功能的扩展（虽然也可以增加一些功能），只是目标角色的功能以间接的方式实现。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ProxySubject.java %0a%3c %0a%3c package designPatterns.Proxy;%0a%3c %0a%3c public class ProxySubject implements Subject {%0a%3c 	private RealSubject realSubject = null;%0a%3c 	%0a%3c 	public ProxySubject() {%0a%3c 		realSubject = new RealSubject();%0a%3c 	}%0a%3c 	%0a%3c 	public void request() {%0a%3c 		System.out.println("ProxySubject.request()");%0a%3c 		preRequest();%0a%3c 		realSubject.request();%0a%3c 		postRequest();%0a%3c 	}%0a%3c 	%0a%3c 	public void preRequest() {%0a%3c 		System.out.println("ProxySubject.preRequest()");%0a%3c 	}%0a%3c 	%0a%3c 	public void postRequest() {%0a%3c 		System.out.println("ProxySubject.postRequest()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  RealSubject.java %0a%3c %0a%3c package designPatterns.Proxy;%0a%3c %0a%3c public class RealSubject implements Subject {%0a%3c 	public void request() {%0a%3c 		System.out.println("RealSubject.request()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Subject.java %0a%3c %0a%3c package designPatterns.Proxy;%0a%3c %0a%3c public interface Subject {%0a%3c 	public void request();%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319032730=117.89.207.43
