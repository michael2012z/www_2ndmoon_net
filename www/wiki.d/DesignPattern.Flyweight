version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319032982
host=117.89.207.43
name=DesignPattern.Flyweight
rev=5
targets=DesignPattern.Flyweight
text=\\%0a%0a[+++'''享元模式/Flyweight'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a享元模式也叫轻量模式（flyweight pattern），因应用大量轻量级对象而得名。%0a%0aFlyweight模式对那些通常因为数量太大而难以用对象来表示的概念或实体进行建模。例如，文档编辑器可以为字母表中的每一个字母创建一个flyweight。每个flyweight存储一个字符代码，但它在文档中的位置和排版风格可以在字符出现时由正文排版算法和使用的格式化命令决定。字符代码是内部状态，而其他的信息则是外部状态。%0a%0a享元对象能做到共享的关键是区分内部状态和外部状态。内部状态存储在享元对象内部，并且是不会随环境改变而有所不同的，这是享元的本质特征。个部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入享元对象中去。外部状态不可以影响享元对象的内部状态，它们是互相独立的。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/SimpleFlyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/SimpleFlyweight.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象享元角色：此角色是所有具体享元类的公共接口。%0a# 具体享元角色：实现抽象享元角色所元宝的接口。如果有内部状态的话，必须负责为内部状态提供存储空间。享元对象的内部状态必须与对象所处的周围环境无关，这是共享的前提。%0a# 享元工厂角色：此角色负责创建和管理享元角色，必须保证享元对象可以被系统适当地共享 。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否有一个符合要求的享元对象。如果有，享元工厂就应当直接提供已有的享元对象；如果没有，享元工厂就应当创建一个合适的享元对象，并提供给客户端。%0a# 客户端角色：本角色需要维护一个对所有享元对象的引用，并自行存储所有享元对象的外部状态。%0a%0a[+++''要点：''+++]%0a%0aFlyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式：%0a# 一个应用程序使用了大量的对象。%0a# 完全由于使用大量的对象，造成很大的存储开销。%0a# 对象的大多数状态都可变为外部状态。%0a# 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。%0a# 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。%0a%0a[+++''扩展：''+++]%0a%0a[++''复合享元模式：''++]%0a%0a下面考虑一个较为复杂的情况，即将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享。%0a%0aUML如图：\\%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/CompositeFlyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/CompositeFlyweight.png]]%0a%0a复合享元模式比单纯享元模式多一种角色：%0a* 复合享元角色：此角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象，它实际上是享元模式的一种应用。%0a%0a复合享元角色是由单纯享元对象通过复合而成，因此它提供了add()这样的聚合集管理方法。由于一个复合享元对象具有不同的聚合元素，这些聚合元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。%0a%0a复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法。这个方法有一个参量，代表复合享元对象的外部状态。一个复合享元对象的所有单纯享元对象元素的外部 状态都是与复合享元对象的外部状态相等的；而一个复合享元对象所含有的单纯享元对象的内部状态一般是不相等的，不然就没有使用价值了。%0a%0a[+++''相关模式：''+++]%0a%0a在应用享元模式的场景中，一般会有大量的享元对象。为了更有效率地实现共享，享元对象最好是禁止由客户端自行创建，只能由享元工厂来创建和管理。%0a%0a可以在享元工厂应用以下两种模式可以起到优化的作用：%0a# 工厂模式：以此来管理享元对象。%0a# 单例模式：以此来保证享元对象和享元工厂都只有一个实例。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  CompositeConcreteFlyweight.java %0a%0apackage designPatterns.Flyweight;%0a%0aimport java.util.HashMap;%0aimport java.util.Iterator;%0aimport java.util.Map;%0a%0apublic class CompositeConcreteFlyweight implements Flyweight {%0a%0a	private HashMap maps = new HashMap();%0a	%0a	public void add(Character key, Flyweight fly) {%0a		maps.put(key, fly);%0a	}%0a	%0a	public void operation(String state) {%0a		Flyweight fly = null;%0a		for (Iterator it = maps.entrySet().iterator(); it.hasNext(); ) {%0a			Map.Entry e = (Map.Entry)it.next();%0a			fly = (Flyweight)e.getValue();%0a			fly.operation(state);%0a		}%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ConcreteFlyweight.java %0a%0apackage designPatterns.Flyweight;%0a%0apublic class ConcreteFlyweight implements Flyweight {%0a	%0a	private Character internalState = null;%0a	%0a	public ConcreteFlyweight(Character state) {%0a		this.internalState = state;%0a	}%0a%0a	public void operation(String state) {%0a		System.out.println("internal state = " + internalState + ", external state = " + state);%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Flyweight.java %0a%0apackage designPatterns.Flyweight;%0a%0apublic interface Flyweight {%0a	public void operation(String state);%0a}%0a%0a%0a// Source code from file:  FlyweightFactory.java %0a%0apackage designPatterns.Flyweight;%0a%0aimport java.util.HashMap;%0a%0apublic class FlyweightFactory {%0a%0a	private HashMap maps = new HashMap();%0a%0a	public Flyweight factory(Character state) {%0a		if (maps.containsKey(state)) {%0a			return (Flyweight)maps.get(state);%0a		} else {%0a			Flyweight flyweight = new ConcreteFlyweight(state);%0a			maps.put(state, flyweight);%0a			return flyweight;%0a		}%0a	}%0a	%0a	public Flyweight factory(String compositeState) {%0a		CompositeConcreteFlyweight compositeFly = new CompositeConcreteFlyweight();%0a		int length = compositeState.length();%0a		Character state = null;%0a		for(int i = 0; i %3c length; i++) {%0a			state = new Character(compositeState.charAt(i));%0a			compositeFly.add(state, this.factory(state));%0a		}%0a		return compositeFly;%0a	}%0a}%0a(:sourcend:)
time=1319036565
author:1319036565=
diff:1319036565:1319036505:=14,15c14,15%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/SimpleFlyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/SimpleFlyweight.png]]%0a%3c %0a---%0a> %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/Flyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/Flyweight.png]]%0a> %0a37,39c37,38%0a%3c UML如图：\\%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/CompositeFlyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/CompositeFlyweight.png]]%0a%3c %0a---%0a> UML如图：%0a>  %0a
host:1319036565=117.89.207.43
author:1319036505=
diff:1319036505:1319033060:=14,15c14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/Flyweight.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Flyweight/Flyweight.png]]%0a%3c %0a---%0a>  %0a
host:1319036505=117.89.207.43
author:1319033060=
diff:1319033060:1319033000:=32c32%0a%3c [++''复合享元模式：''++]%0a---%0a> 复合享元模式：%0a
host:1319033060=117.89.207.43
author:1319033000=
diff:1319033000:1319032982:=3c3%0a%3c [+++'''享元模式/Flyweight'''+++]%0a---%0a> [+++''享元模式/Flyweight''+++]%0a
host:1319033000=117.89.207.43
author:1319032982=
diff:1319032982:1319032982:=1,142d0%0a%3c \\%0a%3c %0a%3c [+++''享元模式/Flyweight''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 享元模式也叫轻量模式（flyweight pattern），因应用大量轻量级对象而得名。%0a%3c %0a%3c Flyweight模式对那些通常因为数量太大而难以用对象来表示的概念或实体进行建模。例如，文档编辑器可以为字母表中的每一个字母创建一个flyweight。每个flyweight存储一个字符代码，但它在文档中的位置和排版风格可以在字符出现时由正文排版算法和使用的格式化命令决定。字符代码是内部状态，而其他的信息则是外部状态。%0a%3c %0a%3c 享元对象能做到共享的关键是区分内部状态和外部状态。内部状态存储在享元对象内部，并且是不会随环境改变而有所不同的，这是享元的本质特征。个部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入享元对象中去。外部状态不可以影响享元对象的内部状态，它们是互相独立的。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象享元角色：此角色是所有具体享元类的公共接口。%0a%3c # 具体享元角色：实现抽象享元角色所元宝的接口。如果有内部状态的话，必须负责为内部状态提供存储空间。享元对象的内部状态必须与对象所处的周围环境无关，这是共享的前提。%0a%3c # 享元工厂角色：此角色负责创建和管理享元角色，必须保证享元对象可以被系统适当地共享 。当一个客户端对象调用一个享元对象的时候，享元工厂角色会检查系统中是否有一个符合要求的享元对象。如果有，享元工厂就应当直接提供已有的享元对象；如果没有，享元工厂就应当创建一个合适的享元对象，并提供给客户端。%0a%3c # 客户端角色：本角色需要维护一个对所有享元对象的引用，并自行存储所有享元对象的外部状态。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式：%0a%3c # 一个应用程序使用了大量的对象。%0a%3c # 完全由于使用大量的对象，造成很大的存储开销。%0a%3c # 对象的大多数状态都可变为外部状态。%0a%3c # 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。%0a%3c # 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。%0a%3c %0a%3c [+++''扩展：''+++]%0a%3c %0a%3c 复合享元模式：%0a%3c %0a%3c 下面考虑一个较为复杂的情况，即将一些单纯享元使用合成模式加以复合，形成复合享元对象。这样的复合享元对象本身不能共享。%0a%3c %0a%3c UML如图：%0a%3c  %0a%3c 复合享元模式比单纯享元模式多一种角色：%0a%3c * 复合享元角色：此角色所代表的对象是不可以共享的，但是一个复合享元对象可以分解为多个本身是单纯享元对象的组合。复合享元角色又称做不可共享的享元对象，它实际上是享元模式的一种应用。%0a%3c %0a%3c 复合享元角色是由单纯享元对象通过复合而成，因此它提供了add()这样的聚合集管理方法。由于一个复合享元对象具有不同的聚合元素，这些聚合元素在复合享元对象被创建之后加入，这本身就意味着复合享元对象的状态是会改变的，因此复合享元对象是不能共享的。%0a%3c %0a%3c 复合享元角色实现了抽象享元角色所规定的接口，也就是operation()方法。这个方法有一个参量，代表复合享元对象的外部状态。一个复合享元对象的所有单纯享元对象元素的外部 状态都是与复合享元对象的外部状态相等的；而一个复合享元对象所含有的单纯享元对象的内部状态一般是不相等的，不然就没有使用价值了。%0a%3c %0a%3c [+++''相关模式：''+++]%0a%3c %0a%3c 在应用享元模式的场景中，一般会有大量的享元对象。为了更有效率地实现共享，享元对象最好是禁止由客户端自行创建，只能由享元工厂来创建和管理。%0a%3c %0a%3c 可以在享元工厂应用以下两种模式可以起到优化的作用：%0a%3c # 工厂模式：以此来管理享元对象。%0a%3c # 单例模式：以此来保证享元对象和享元工厂都只有一个实例。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  CompositeConcreteFlyweight.java %0a%3c %0a%3c package designPatterns.Flyweight;%0a%3c %0a%3c import java.util.HashMap;%0a%3c import java.util.Iterator;%0a%3c import java.util.Map;%0a%3c %0a%3c public class CompositeConcreteFlyweight implements Flyweight {%0a%3c %0a%3c 	private HashMap maps = new HashMap();%0a%3c 	%0a%3c 	public void add(Character key, Flyweight fly) {%0a%3c 		maps.put(key, fly);%0a%3c 	}%0a%3c 	%0a%3c 	public void operation(String state) {%0a%3c 		Flyweight fly = null;%0a%3c 		for (Iterator it = maps.entrySet().iterator(); it.hasNext(); ) {%0a%3c 			Map.Entry e = (Map.Entry)it.next();%0a%3c 			fly = (Flyweight)e.getValue();%0a%3c 			fly.operation(state);%0a%3c 		}%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteFlyweight.java %0a%3c %0a%3c package designPatterns.Flyweight;%0a%3c %0a%3c public class ConcreteFlyweight implements Flyweight {%0a%3c 	%0a%3c 	private Character internalState = null;%0a%3c 	%0a%3c 	public ConcreteFlyweight(Character state) {%0a%3c 		this.internalState = state;%0a%3c 	}%0a%3c %0a%3c 	public void operation(String state) {%0a%3c 		System.out.println("internal state = " + internalState + ", external state = " + state);%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Flyweight.java %0a%3c %0a%3c package designPatterns.Flyweight;%0a%3c %0a%3c public interface Flyweight {%0a%3c 	public void operation(String state);%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  FlyweightFactory.java %0a%3c %0a%3c package designPatterns.Flyweight;%0a%3c %0a%3c import java.util.HashMap;%0a%3c %0a%3c public class FlyweightFactory {%0a%3c %0a%3c 	private HashMap maps = new HashMap();%0a%3c %0a%3c 	public Flyweight factory(Character state) {%0a%3c 		if (maps.containsKey(state)) {%0a%3c 			return (Flyweight)maps.get(state);%0a%3c 		} else {%0a%3c 			Flyweight flyweight = new ConcreteFlyweight(state);%0a%3c 			maps.put(state, flyweight);%0a%3c 			return flyweight;%0a%3c 		}%0a%3c 	}%0a%3c 	%0a%3c 	public Flyweight factory(String compositeState) {%0a%3c 		CompositeConcreteFlyweight compositeFly = new CompositeConcreteFlyweight();%0a%3c 		int length = compositeState.length();%0a%3c 		Character state = null;%0a%3c 		for(int i = 0; i %3c length; i++) {%0a%3c 			state = new Character(compositeState.charAt(i));%0a%3c 			compositeFly.add(state, this.factory(state));%0a%3c 		}%0a%3c 		return compositeFly;%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319032982=117.89.207.43
