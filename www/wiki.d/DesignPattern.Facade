version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319033151
host=117.89.207.43
name=DesignPattern.Facade
rev=2
targets=DesignPattern.Facade
text=\\%0a %0a[+++'''门面模式/Facade'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a设计师处理很杂系统 的一个常见方法是“分而治之”，把一个系统划分为几个较小的子系统，每个子系统提供一种单一的服务。这样做之后，可能会出现大量的子系统，客户端往往要同时与很多子系统打交道之后才能达到目的。%0a%0a门面模式创造出一个门面对象，将客户端所涉及的具体子系统数目减至最小，使用客户端与众多了系统的相互作用被门面对象所取代。显然，门面模式是实现代码重构以便达到迪米特法则要求的一个强大有力的武器。%0a%0a一个典型的例子是中国的医院。这个职能部门就相当于各个子系统，比如挂号、门诊、化验、收费、取药等等。看病的人要与所有这些部门打交道。如果有一个接待员（相当于门面）负责代为挂号缴费、取药的话，病人就可以从繁琐的流程是解放出来。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Facade/Facade.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Facade/Facade.png]]%0a%0a[+++''参与者：''+++]%0a# 服务者(server)：为客户端提供服务。系统中存在众多的服务者，每一个服务者为客户提供某一种服务。%0a# 客户(Client)：服务的使用者。%0a# 门面(Facade)：与各个服务者打资产，处理繁琐的逻辑。为客户提供简单的接口。%0a%0a[+++''要点：''+++]%0a%0a门面模式的要点是在客户端与服务者之间增加一个“集线器”，减轻客户端的负担，把客户端从繁琐的逻辑中解放出来。%0a%0a“门面”本身并不提供附加的功能，只是承担了处理复杂逻辑的工作，从而为客户端提供更加简单的接口。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Facade.java %0a%0apackage designPatterns.Facade;%0a%0apublic class Facade {%0a	private ServerA serverA = new ServerA();%0a	private ServerB serverB = new ServerB();%0a	private ServerC serverC = new ServerC();%0a	private ServerD serverD = new ServerD();%0a	%0a	public void service() {%0a		serverA.service();%0a		serverB.service();%0a		serverC.service();%0a		serverD.service();%0a	}%0a}%0a%0a%0a// Source code from file:  Server.java %0a%0apackage designPatterns.Facade;%0a%0apublic interface Server {%0a	public void service();%0a}%0a%0a%0a// Source code from file:  ServerA.java %0a%0apackage designPatterns.Facade;%0a%0apublic class ServerA implements Server {%0a%0a	public void service() {%0a		System.out.println("Service of ServerA");%0a	}%0a}%0a%0a%0a// Source code from file:  ServerB.java %0a%0apackage designPatterns.Facade;%0a%0apublic class ServerB implements Server {%0a%0a	public void service() {%0a		System.out.println("Service of ServerB");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ServerC.java %0a%0apackage designPatterns.Facade;%0a%0apublic class ServerC implements Server {%0a%0a	public void service() {%0a		System.out.println("Service of ServerC");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ServerD.java %0a%0apackage designPatterns.Facade;%0a%0apublic class ServerD implements Server {%0a%0a	public void service() {%0a		System.out.println("Service of ServerD");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Facade;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Facade facade = new Facade();%0a		facade.service();%0a	}%0a}%0a(:sourcend:)
time=1319036599
author:1319036599=
diff:1319036599:1319033151:=14,15c14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Facade/Facade.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Facade/Facade.png]]%0a%3c %0a---%0a>  %0a
host:1319036599=117.89.207.43
author:1319033151=
diff:1319033151:1319033151:=1,117d0%0a%3c \\%0a%3c  %0a%3c [+++'''门面模式/Facade'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 设计师处理很杂系统 的一个常见方法是“分而治之”，把一个系统划分为几个较小的子系统，每个子系统提供一种单一的服务。这样做之后，可能会出现大量的子系统，客户端往往要同时与很多子系统打交道之后才能达到目的。%0a%3c %0a%3c 门面模式创造出一个门面对象，将客户端所涉及的具体子系统数目减至最小，使用客户端与众多了系统的相互作用被门面对象所取代。显然，门面模式是实现代码重构以便达到迪米特法则要求的一个强大有力的武器。%0a%3c %0a%3c 一个典型的例子是中国的医院。这个职能部门就相当于各个子系统，比如挂号、门诊、化验、收费、取药等等。看病的人要与所有这些部门打交道。如果有一个接待员（相当于门面）负责代为挂号缴费、取药的话，病人就可以从繁琐的流程是解放出来。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 服务者(server)：为客户端提供服务。系统中存在众多的服务者，每一个服务者为客户提供某一种服务。%0a%3c # 客户(Client)：服务的使用者。%0a%3c # 门面(Facade)：与各个服务者打资产，处理繁琐的逻辑。为客户提供简单的接口。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 门面模式的要点是在客户端与服务者之间增加一个“集线器”，减轻客户端的负担，把客户端从繁琐的逻辑中解放出来。%0a%3c %0a%3c “门面”本身并不提供附加的功能，只是承担了处理复杂逻辑的工作，从而为客户端提供更加简单的接口。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Facade.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class Facade {%0a%3c 	private ServerA serverA = new ServerA();%0a%3c 	private ServerB serverB = new ServerB();%0a%3c 	private ServerC serverC = new ServerC();%0a%3c 	private ServerD serverD = new ServerD();%0a%3c 	%0a%3c 	public void service() {%0a%3c 		serverA.service();%0a%3c 		serverB.service();%0a%3c 		serverC.service();%0a%3c 		serverD.service();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Server.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public interface Server {%0a%3c 	public void service();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ServerA.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class ServerA implements Server {%0a%3c %0a%3c 	public void service() {%0a%3c 		System.out.println("Service of ServerA");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ServerB.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class ServerB implements Server {%0a%3c %0a%3c 	public void service() {%0a%3c 		System.out.println("Service of ServerB");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ServerC.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class ServerC implements Server {%0a%3c %0a%3c 	public void service() {%0a%3c 		System.out.println("Service of ServerC");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ServerD.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class ServerD implements Server {%0a%3c %0a%3c 	public void service() {%0a%3c 		System.out.println("Service of ServerD");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Facade;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Facade facade = new Facade();%0a%3c 		facade.service();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319033151=117.89.207.43
