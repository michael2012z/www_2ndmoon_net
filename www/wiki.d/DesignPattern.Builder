version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319030754
host=117.89.207.43
name=DesignPattern.Builder
rev=2
targets=DesignPattern.Builder
text=\\%0a%0a[+++'''建造模式/Builder'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a如果一个产品由很多的配件组成，缺少了其中某一个配件，产品都不能工作。产品只有在所有配件都装配完成的情况下才能正常工作。对于这样的产品，不希望外界干预它的生产过程，在外界看来，生产者只提供完整的产品，而不提供任何的中间过程信息。这就是一个建造模式的应用场景。%0a%0a建造模式的另一个方面在于，系统还提供不同的生产者，它们生产不两只的产品，但同样都不提供内部信息。%0a%0a所以，在以下情况下可以使用Builder模式：%0a# 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。%0a# 当构造过程必须允许被构造的对象有不同的表示时。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Builder/Builder.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Builder/Builder.png]]%0a%0a%0a[+++''参与者：''+++]%0a# 抽象建造者(Builder)：%0a** 为创建一个Product对象的各个部件指定抽象接口。%0a# 具体建造者(ConcreteBuilder)：%0a** 实现Builder的接口以构造和装配该产品的各个部件。%0a** 定义并明确它所创建的表示。%0a** 提供一个检索产品的接口。%0a# 向导(Director)：%0a** 构造一个使用Builder接口的对象。%0a# 产品(Product)：%0a** 表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。%0a** 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。%0a%0a[+++''应用实例：''+++]%0a%0a参考《设计模式》书中本章“RTF（Rich Text Format）文档交换格式的阅读器”的例子。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Builder.java %0a%0apackage designPatterns.Builder;%0a%0apublic interface Builder {%0a	public void buildPart1();%0a	public void buildPart2();%0a}%0a%0a%0a// Source code from file:  ConcreteBuilder.java %0a%0apackage designPatterns.Builder;%0a%0apublic class ConcreteBuilder implements Builder {%0a	%0a	public void buildPart1() {%0a		// do something%0a	}%0a%0a	public void buildPart2() {%0a		// do something%0a	}%0a%0a	public Product getProduct() {%0a		Product p = new Product();%0a		buildPart1();%0a		buildPart2();%0a		return p;%0a	}%0a}%0a%0a%0a// Source code from file:  Director.java %0a%0apackage designPatterns.Builder;%0a%0apublic class Director {%0a%0a	public Product buildProduct() {%0a		ConcreteBuilder builder = new ConcreteBuilder();%0a		return builder.getProduct();%0a	}%0a	%0a	public static void main(String[] args) {%0a		Director director = new Director();%0a		director.buildProduct();%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Product.java %0a%0apackage designPatterns.Builder;%0a%0apublic class Product {%0a%0a}%0a(:sourcend:)
time=1319036163
author:1319036163=
diff:1319036163:1319030754:=16,18c16%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Builder/Builder.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Builder/Builder.png]]%0a%3c %0a%3c %0a---%0a>  %0a
host:1319036163=117.89.207.43
author:1319030754=
diff:1319030754:1319030754:=1,95d0%0a%3c \\%0a%3c %0a%3c [+++'''建造模式/Builder'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 如果一个产品由很多的配件组成，缺少了其中某一个配件，产品都不能工作。产品只有在所有配件都装配完成的情况下才能正常工作。对于这样的产品，不希望外界干预它的生产过程，在外界看来，生产者只提供完整的产品，而不提供任何的中间过程信息。这就是一个建造模式的应用场景。%0a%3c %0a%3c 建造模式的另一个方面在于，系统还提供不同的生产者，它们生产不两只的产品，但同样都不提供内部信息。%0a%3c %0a%3c 所以，在以下情况下可以使用Builder模式：%0a%3c # 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。%0a%3c # 当构造过程必须允许被构造的对象有不同的表示时。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象建造者(Builder)：%0a%3c ** 为创建一个Product对象的各个部件指定抽象接口。%0a%3c # 具体建造者(ConcreteBuilder)：%0a%3c ** 实现Builder的接口以构造和装配该产品的各个部件。%0a%3c ** 定义并明确它所创建的表示。%0a%3c ** 提供一个检索产品的接口。%0a%3c # 向导(Director)：%0a%3c ** 构造一个使用Builder接口的对象。%0a%3c # 产品(Product)：%0a%3c ** 表示被构造的复杂对象。ConcreteBuilder创建该产品的内部表示并定义它的装配过程。%0a%3c ** 包含定义组成部件的类，包括将这些部件装配成最终产品的接口。%0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c %0a%3c 参考《设计模式》书中本章“RTF（Rich Text Format）文档交换格式的阅读器”的例子。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Builder.java %0a%3c %0a%3c package designPatterns.Builder;%0a%3c %0a%3c public interface Builder {%0a%3c 	public void buildPart1();%0a%3c 	public void buildPart2();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteBuilder.java %0a%3c %0a%3c package designPatterns.Builder;%0a%3c %0a%3c public class ConcreteBuilder implements Builder {%0a%3c 	%0a%3c 	public void buildPart1() {%0a%3c 		// do something%0a%3c 	}%0a%3c %0a%3c 	public void buildPart2() {%0a%3c 		// do something%0a%3c 	}%0a%3c %0a%3c 	public Product getProduct() {%0a%3c 		Product p = new Product();%0a%3c 		buildPart1();%0a%3c 		buildPart2();%0a%3c 		return p;%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Director.java %0a%3c %0a%3c package designPatterns.Builder;%0a%3c %0a%3c public class Director {%0a%3c %0a%3c 	public Product buildProduct() {%0a%3c 		ConcreteBuilder builder = new ConcreteBuilder();%0a%3c 		return builder.getProduct();%0a%3c 	}%0a%3c 	%0a%3c 	public static void main(String[] args) {%0a%3c 		Director director = new Director();%0a%3c 		director.buildProduct();%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Product.java %0a%3c %0a%3c package designPatterns.Builder;%0a%3c %0a%3c public class Product {%0a%3c %0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319030754=117.89.207.43
