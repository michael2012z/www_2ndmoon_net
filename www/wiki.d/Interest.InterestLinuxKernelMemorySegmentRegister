version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; SLCC1; .NET CLR 2.0.50727; .NET CLR 1.1.4322; InfoPath.1; OfficeLiveConnector.1.3; OfficeLivePatch.0.0; .NET CLR 3.5.30729; .NET CLR 3.0.30618) chromeframe/5.0.375.15
author=
charset=UTF-8
csum=
ctime=1272836581
host=194.237.142.7
name=Interest.InterestLinuxKernelMemorySegmentRegister
rev=20
targets=
text=!!! 一、 段寄存器的产生%0a%0a段寄存器的产生源于Intel 8086 CPU体系结构中数据总线与地址总线的宽度不一致。%0a%0a数据总线的宽度，也即是ALU(算数逻辑单元)的宽度，平常说一个CPU是“16位”或者“32位”指的就是这个。8086CPU的数据总线是16位。%0a%0a地址总线的宽度不一定要与ALU的宽度相同。因为ALU的宽度是固定的，它受限于当时的工艺水平，当时只能制造出16位的ALU；但地址总线不一样，它可以设计得更宽。地址总线的宽度如果与ALU相同当然是不错的办法，这样CPU的结构比较均衡，寻址可以在单个指令周期内完成，效率最高；而且从软件的解决来看，一个变量地址的长度可以用整型或者长整型来表示会比较方便。%0a%0a但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了系统可寻址的范围，即可以支持多少内存。如果地址总线太窄的话，可寻址范围会很小。如果地址总线设计为16位的话，可寻址空间是2^16=64KB，这在当时被认为是不够的；Intel最终决定要让8086的地址空间为1M，也就是20位地址总线。%0a%0a地址总线宽度大于数据总线会带来一些麻烦，ALU无法在单个指令周期里完成对地址数据的运算。有一些容易想到的可行的办法，比如定义一个新的寄存器专门用于存放地址的高4位，但这样增加了计算的复杂性，程序员要增加成倍的汇编代码来操作地址数据而且无法保持兼容性。%0a%0aIntel想到了一个折中的办法：把内存分段，并设计了4个段寄存器，CS，DS，ES和SS，分别用于指令、数据、其它和堆栈。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a%0a||border=1 width=80%25%0a|| Base || b15 ~ b12 || b11 ~ b0 || ||%0a|| Offset || || o15 ~ o4 || o3 ~ o0 ||%0a|| Address || a19 ~ a0 ||||||%0a%0a这种寻址模式也就是“实地址模式”。在8086中，段寄存器还只是一个单纯的16位寄存器，而且操作寄存器的指令也不是特权指令。通过设置段寄存器和段内偏移，程序就可以访问整个物理内存，无安全性可言。%0a%0a总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Intel系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。%0a%0a!!! 二、 实现保护模式%0a%0a到了80386问世的时候，工艺已经有了很大的进步，386的ALU有已经从16位跃升为32位，也就是说，38086是32位的CPU，而且结构也已经比较成熟，接下来的80486一直到Pentium系列虽然速度提高了几个数量级，但并没有质的变化，所以被统称为i386结构。%0a%0a对于32位的CPU来说，只要地址总线宽度与数据总线宽度相同，就可以寻址2^32=4GB的内存空间，这已经足够用，已经不再需要段寄存器来帮助扩展。但这时Intel已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。%0a%0a这时，技术的发展需求Intel在其CPU中实现“保护模式”，用户程序的可访问内存范围必须受到限制，不能再任意地访问内存所有地址。Intel决定利用段寄存器来实现他们的保护模式，把保护模式建立在段寄存器的基础之上。%0a%0a对于段的描述不再只是一个20位的起始地址，而是全新地定义了“段描述项”。段描述项的结构如下：%0a%0a||border=1 width=80%25%0a|| B31 ~ B24 |||| DES1 (4 bit) || L19 ~ L16 ||%0a|| DES2 (8 bit) |||| B23 ~ B16 ||||%0a|| B15 ~ B0 ||||||||%0a|| L15 ~ L0 ||||||||%0a%0a每一行是两个字节，总共8个字节，64位。%0a%0aDES1和DES2分别是一些描述信息，用于描述本段是数据段还是代码段，以及读写权限等等。B0~B31是段的基地址，L0~L19是段的长度。%0a%0a注意，规定段的长度是非常必要的，如果不限定段长度，“保护”就无从谈起，用户程序的访问至少不能超过段的范围。另外，段长度只有20位，所代表的最大可能长度为2^20=1M，而整个地址空间是2^32=4GB，这样来看，段的长度是不是太短了？其实，在DES1中，有一位用于表示段长度的单位，当它被置1时(一般情况下都是如此)，表示长度单位为4KB，这样，一个段的最大可能尺寸就成了1M*4K=4G，与地址空间相稳合。4KB也正是一个内存页的大小，说明段的大小也是向页对齐的。%0a%0a另外，注意到一个有趣的现象吗？段描述项的结构被设计得不连续，不论是段基地址还是段长度，都被分成了两节表示。这样的设计与80286的过渡有关。上面的段描述项结构去掉第一行后剩下的三行正是286的段描述项。286被设计为24位地址总线，所以段基址是24位，相应地段长是16位。在386的地址总线扩展为32位之后，还必须兼容286产品的设计，所以只好在段描述项上“打补丁”。%0a%0a在386中，段寄存器还是16位，那么16位的段寄存器如何存放得下64位的段描述项？ 段描述项不再由段寄存器直接持有。段描述项存放在内存里，系统中可以有很多个段描述项，这些项连续存放，共同构成一张表，16位的段寄存器里只是含有这张表里的一个索引，但也并不仅是一个简单的序号，而是存储了一种数据结构，这种结构的定义如下：%0a%0a||border=1 width=80%25%0a|| index (b15 ~ b3) || TI (b2) || RPL (b1 ~ b0) ||%0a%0a其中index是段描述表的索引，它指向其中的某一个段描述项。RPL表示权限，00最高，11最低。%0a%0a还有一个关键的问题，内存中的段描述表的起始地址在哪里？显然光有索引是有不够的。为此，Intel又设计了两个新的寄存器：GDTR(global descriptor table register)和LDTR(local descriptor table register)，分别用来存储段描述表的地址。段寄存器中的TI位正是用于指示使用GDTR还是LDTR。%0a%0a当用户程序要求访问内存时，CPU根据指令的性质确定使用哪个段寄存器，转移指令中的地址在代码段，取数指令中的地址在数据段；根据段寄存器中的索引值，找到段描述项，取得段基址；指令中的地址是段内偏移，与段长比较，确保没有越界；检查权限；把段基址和偏移相加，构成物理地址，取得数据。%0a%0a新的设计中处处有权限与范围的限制，用户程序只能访问被授权的内存空间，从而实现了保护机制。就这样，在段寄存器的基础上，Intel实现了自己的“保护模式”。%0a%0a%0a!!! 三、 与页式存管并存%0a%0a现代操作系统的发展要求CPU支持页式存储管理。%0a%0a页式存管本身是与段式存管分立的，两者没有什么关系。但对于Intel来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。%0a%0a在段式存管中，由程序发出的变量地址经映射（段基址+段内偏移）之后，得到的32位地址就是一个物理地址，是可以直接放到地址总线是去取数的。%0a%0a在页式存管中，过程也是相似的，由程序发出的变量地址并不是实际的物理地址，而是一个三层的索引结构，这个地址经过一系统的映射之后才可以得到物理地址。%0a%0a现在对于Intel CPU来说，以上两个映射过程就要先后各做一次。由程序发出的变量地址称为“逻辑地址”，先经过段式映射成为“线性地址”，线性地址再做为页式映射的输入，最后得到“物理地址”。%0a%0aLinux内核实现了页式存储管理，而且并没有因为两层存管的映射而变得更复杂。Linux更关注页式内存管理，对于段式映射，采用了特殊的方式把它简化。让每个段寄存器都指向同一个段描述项，即只设了一个段，而这个段的基地址为0，段长度设为最大值4G，这个段就与整个物理内存相重合，逻辑地址经映射之后就与线性地址相同，从而把段式存管变成“透明”的。%0a%0a%0a这，就是Intel处理器中“段寄存器”的故事。%0a
time=1272910391
author:1272910391=
diff:1272910391:1272907930:=3,4c3,4%0a%3c 段寄存器的产生源于Intel 8086 CPU体系结构中数据总线与地址总线的宽度不一致。%0a%3c %0a---%0a> 段寄存器的产生源于Inter 8086 CPU体系结构中数据总线与地址总线的宽度不一致。%0a> %0a9,10c9,10%0a%3c 但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了系统可寻址的范围，即可以支持多少内存。如果地址总线太窄的话，可寻址范围会很小。如果地址总线设计为16位的话，可寻址空间是2^16=64KB，这在当时被认为是不够的；Intel最终决定要让8086的地址空间为1M，也就是20位地址总线。%0a%3c %0a---%0a> 但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了系统可寻址的范围，即可以支持多少内存。如果地址总线太窄的话，可寻址范围会很小。如果地址总线设计为16位的话，可寻址空间是2^16=64KB，这在当时被认为是不够的；Inter最终决定要让8086的地址空间为1M，也就是20位地址总线。%0a> %0a13,14c13,14%0a%3c Intel想到了一个折中的办法：把内存分段，并设计了4个段寄存器，CS，DS，ES和SS，分别用于指令、数据、其它和堆栈。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a%3c %0a---%0a> Inter想到了一个折中的办法：把内存分段，并设计了4个段寄存器，CS，DS，ES和SS，分别用于指令、数据、其它和堆栈。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a> %0a22,23c22,23%0a%3c 总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Intel系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。%0a%3c %0a---%0a> 总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Inter系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。%0a> %0a28,31c28,31%0a%3c 对于32位的CPU来说，只要地址总线宽度与数据总线宽度相同，就可以寻址2^32=4GB的内存空间，这已经足够用，已经不再需要段寄存器来帮助扩展。但这时Intel已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。%0a%3c %0a%3c 这时，技术的发展需求Intel在其CPU中实现“保护模式”，用户程序的可访问内存范围必须受到限制，不能再任意地访问内存所有地址。Intel决定利用段寄存器来实现他们的保护模式，把保护模式建立在段寄存器的基础之上。%0a%3c %0a---%0a> 对于32位的CPU来说，只要地址总线宽度与数据总线宽度相同，就可以寻址2^32=4GB的内存空间，这已经足够用，已经不再需要段寄存器来帮助扩展。但这时Inter已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。%0a> %0a> 这时，技术的发展需求Inter在其CPU中实现“保护模式”，用户程序的可访问内存范围必须受到限制，不能再任意地访问内存所有地址。Inter决定利用段寄存器来实现他们的保护模式，把保护模式建立在段寄存器的基础之上。%0a> %0a55,56c55,56%0a%3c 还有一个关键的问题，内存中的段描述表的起始地址在哪里？显然光有索引是有不够的。为此，Intel又设计了两个新的寄存器：GDTR(global descriptor table register)和LDTR(local descriptor table register)，分别用来存储段描述表的地址。段寄存器中的TI位正是用于指示使用GDTR还是LDTR。%0a%3c %0a---%0a> 还有一个关键的问题，内存中的段描述表的起始地址在哪里？显然光有索引是有不够的。为此，Inter又设计了两个新的寄存器：GDTR(global descriptor table register)和LDTR(local descriptor table register)，分别用来存储段描述表的地址。段寄存器中的TI位正是用于指示使用GDTR还是LDTR。%0a> %0a59,61c59,61%0a%3c 新的设计中处处有权限与范围的限制，用户程序只能访问被授权的内存空间，从而实现了保护机制。就这样，在段寄存器的基础上，Intel实现了自己的“保护模式”。%0a%3c %0a%3c %0a---%0a> 新的设计中处处有权限与范围的限制，用户程序只能访问被授权的内存空间，从而实现了保护机制。就这样，在段寄存器的基础上，Inter实现了自己的“保护模式”。%0a> %0a> %0a66,67c66,67%0a%3c 页式存管本身是与段式存管分立的，两者没有什么关系。但对于Intel来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。%0a%3c %0a---%0a> 页式存管本身是与段式存管分立的，两者没有什么关系。但对于Inter来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。%0a> %0a72,73c72,73%0a%3c 现在对于Intel CPU来说，以上两个映射过程就要先后各做一次。由程序发出的变量地址称为“逻辑地址”，先经过段式映射成为“线性地址”，线性地址再做为页式映射的输入，最后得到“物理地址”。%0a%3c %0a---%0a> 现在对于Inter CPU来说，以上两个映射过程就要先后各做一次。由程序发出的变量地址称为“逻辑地址”，先经过段式映射成为“线性地址”，线性地址再做为页式映射的输入，最后得到“物理地址”。%0a> %0a77c77%0a%3c 这，就是Intel处理器中“段寄存器”的故事。%0a---%0a> 这，就是Inter处理器中“段寄存器”的故事。%0a
host:1272910391=194.237.142.7
author:1272907930=
diff:1272907930:1272907886:=1,2c1,2%0a%3c !!! 一、 段寄存器的产生%0a%3c %0a---%0a> !! 一、 段寄存器的产生%0a> %0a24,25c24,25%0a%3c !!! 二、 实现保护模式%0a%3c %0a---%0a> !! 二、 实现保护模式%0a> %0a62c62%0a%3c !!! 三、 与页式存管并存%0a---%0a> !! 三、 与页式存管并存%0a
host:1272907930=194.237.142.7
author:1272907886=
diff:1272907886:1272907675:=1,2c1,2%0a%3c !! 一、 段寄存器的产生%0a%3c %0a---%0a> 1 段寄存器的产生%0a> %0a24,25c24,25%0a%3c !! 二、 实现保护模式%0a%3c %0a---%0a> 2 实现保护模式%0a> %0a62c62%0a%3c !! 三、 与页式存管并存%0a---%0a> 3 与页式存管并存%0a
host:1272907886=194.237.142.7
author:1272907675=
diff:1272907675:1272906750:=73,77d72%0a%3c %0a%3c Linux内核实现了页式存储管理，而且并没有因为两层存管的映射而变得更复杂。Linux更关注页式内存管理，对于段式映射，采用了特殊的方式把它简化。让每个段寄存器都指向同一个段描述项，即只设了一个段，而这个段的基地址为0，段长度设为最大值4G，这个段就与整个物理内存相重合，逻辑地址经映射之后就与线性地址相同，从而把段式存管变成“透明”的。%0a%3c %0a%3c %0a%3c 这，就是Inter处理器中“段寄存器”的故事。%0a
host:1272907675=194.237.142.7
author:1272906750=
diff:1272906750:1272905516:=63,72d62%0a%3c %0a%3c 现代操作系统的发展要求CPU支持页式存储管理。%0a%3c %0a%3c 页式存管本身是与段式存管分立的，两者没有什么关系。但对于Inter来说，同样是由于“段寄存器”这个历史的原因，它必须把页式存管建立在段式存管的基础之上，尽管这从设计的角度来说这是没有道理，也根本没有必要的。%0a%3c %0a%3c 在段式存管中，由程序发出的变量地址经映射（段基址+段内偏移）之后，得到的32位地址就是一个物理地址，是可以直接放到地址总线是去取数的。%0a%3c %0a%3c 在页式存管中，过程也是相似的，由程序发出的变量地址并不是实际的物理地址，而是一个三层的索引结构，这个地址经过一系统的映射之后才可以得到物理地址。%0a%3c %0a%3c 现在对于Inter CPU来说，以上两个映射过程就要先后各做一次。由程序发出的变量地址称为“逻辑地址”，先经过段式映射成为“线性地址”，线性地址再做为页式映射的输入，最后得到“物理地址”。%0a
host:1272906750=194.237.142.7
author:1272905516=
diff:1272905516:1272904082:=48,49c48,50%0a%3c 在386中，段寄存器还是16位，那么16位的段寄存器如何存放得下64位的段描述项？ 段描述项不再由段寄存器直接持有。段描述项存放在内存里，系统中可以有很多个段描述项，这些项连续存放，共同构成一张表，16位的段寄存器里只是含有这张表里的一个索引，但也并不仅是一个简单的序号，而是存储了一种数据结构，这种结构的定义如下：%0a%3c %0a---%0a> %0a> 16位的段寄存器不再被用做存储段的起始地址，而是用于存储一种数据结构，这种结构的定义如下：%0a> %0a53,59d53%0a%3c 其中index是段描述表的索引，它指向其中的某一个段描述项。RPL表示权限，00最高，11最低。%0a%3c %0a%3c 还有一个关键的问题，内存中的段描述表的起始地址在哪里？显然光有索引是有不够的。为此，Inter又设计了两个新的寄存器：GDTR(global descriptor table register)和LDTR(local descriptor table register)，分别用来存储段描述表的地址。段寄存器中的TI位正是用于指示使用GDTR还是LDTR。%0a%3c %0a%3c 当用户程序要求访问内存时，CPU根据指令的性质确定使用哪个段寄存器，转移指令中的地址在代码段，取数指令中的地址在数据段；根据段寄存器中的索引值，找到段描述项，取得段基址；指令中的地址是段内偏移，与段长比较，确保没有越界；检查权限；把段基址和偏移相加，构成物理地址，取得数据。%0a%3c %0a%3c 新的设计中处处有权限与范围的限制，用户程序只能访问被授权的内存空间，从而实现了保护机制。就这样，在段寄存器的基础上，Inter实现了自己的“保护模式”。%0a
host:1272905516=194.237.142.7
author:1272904082=
diff:1272904082:1272903435:=40,41d39%0a%3c 每一行是两个字节，总共8个字节，64位。%0a%3c %0a46d43%0a%3c 另外，注意到一个有趣的现象吗？段描述项的结构被设计得不连续，不论是段基地址还是段长度，都被分成了两节表示。这样的设计与80286的过渡有关。上面的段描述项结构去掉第一行后剩下的三行正是286的段描述项。286被设计为24位地址总线，所以段基址是24位，相应地段长是16位。在386的地址总线扩展为32位之后，还必须兼容286产品的设计，所以只好在段描述项上“打补丁”。%0a
host:1272904082=194.237.142.7
author:1272903435=
diff:1272903435:1272902411:=35,36c35,36%0a%3c || B31 ~ B24 |||| DES1 (4 bit) || L19 ~ L16 ||%0a%3c || DES2 (8 bit) |||| B23 ~ B16 ||||%0a---%0a> || B31 ~ B24 |||| DES1 || L19 ~ L16 ||%0a> || DES2 |||| B23 ~ B16 ||||%0a39,42d38%0a%3c %0a%3c DES1和DES2分别是一些描述信息，用于描述本段是数据段还是代码段，以及读写权限等等。B0~B31是段的基地址，L0~L19是段的长度。%0a%3c %0a%3c 注意，规定段的长度是非常必要的，如果不限定段长度，“保护”就无从谈起，用户程序的访问至少不能超过段的范围。另外，段长度只有20位，所代表的最大可能长度为2^20=1M，而整个地址空间是2^32=4GB，这样来看，段的长度是不是太短了？其实，在DES1中，有一位用于表示段长度的单位，当它被置1时(一般情况下都是如此)，表示长度单位为4KB，这样，一个段的最大可能尺寸就成了1M*4K=4G，与地址空间相稳合。4KB也正是一个内存页的大小，说明段的大小也是向页对齐的。%0a
host:1272903435=194.237.142.7
author:1272902411=
diff:1272902411:1272901290:=29,47d28%0a%3c %0a%3c 这时，技术的发展需求Inter在其CPU中实现“保护模式”，用户程序的可访问内存范围必须受到限制，不能再任意地访问内存所有地址。Inter决定利用段寄存器来实现他们的保护模式，把保护模式建立在段寄存器的基础之上。%0a%3c %0a%3c 对于段的描述不再只是一个20位的起始地址，而是全新地定义了“段描述项”。段描述项的结构如下：%0a%3c %0a%3c ||border=1 width=80%25%0a%3c || B31 ~ B24 |||| DES1 || L19 ~ L16 ||%0a%3c || DES2 |||| B23 ~ B16 ||||%0a%3c || B15 ~ B0 ||||||||%0a%3c || L15 ~ L0 ||||||||%0a%3c %0a%3c %0a%3c %0a%3c 16位的段寄存器不再被用做存储段的起始地址，而是用于存储一种数据结构，这种结构的定义如下：%0a%3c %0a%3c ||border=1 width=80%25%0a%3c || index (b15 ~ b3) || TI (b2) || RPL (b1 ~ b0) ||%0a%3c %0a%3c %0a
host:1272902411=194.237.142.7
author:1272901290=
diff:1272901290:1272900550:=25,28d24%0a%3c %0a%3c 到了80386问世的时候，工艺已经有了很大的进步，386的ALU有已经从16位跃升为32位，也就是说，38086是32位的CPU，而且结构也已经比较成熟，接下来的80486一直到Pentium系列虽然速度提高了几个数量级，但并没有质的变化，所以被统称为i386结构。%0a%3c %0a%3c 对于32位的CPU来说，只要地址总线宽度与数据总线宽度相同，就可以寻址2^32=4GB的内存空间，这已经足够用，已经不再需要段寄存器来帮助扩展。但这时Inter已经无法把段寄存器从产品中去掉，因为新的CPU也是产品系列中的一员，根据兼容性的需要，段寄存器必须保留下来。%0a
host:1272901290=194.237.142.7
author:1272900550=
diff:1272900550:1272840371:=22,24c22%0a%3c 总之一句话，段寄存器的设计是一个权宜之计，现在看来可以说是一个临时性的解决方案，设计它的目的是为了把地址空间从64KB扩展为1MB，仅此而已。但是它的加入却为日后Inter系列芯片的发展带来诸多不便，也为理解i386体系带来困扰。%0a%3c %0a%3c 2 实现保护模式%0a---%0a> 2 段寄存器的扩展%0a
host:1272900550=194.237.142.7
author:1272840371=
diff:1272840371:1272840055:=14,18d13%0a%3c %0a%3c ||border=1 width=80%25%0a%3c || Base || b15 ~ b12 || b11 ~ b0 || ||%0a%3c || Offset || || o15 ~ o4 || o3 ~ o0 ||%0a%3c || Address || a19 ~ a0 ||||||%0a
host:1272840371=81.232.107.137
author:1272840055=
diff:1272840055:1272839977:=
host:1272840055=81.232.107.137
author:1272839977=
diff:1272839977:1272839918:=19c19%0a%3c 3 与页式存管并存%0a---%0a> 3 与页式存管并存%0a\ No newline at end of file%0a
host:1272839977=81.232.107.137
author:1272839918=
diff:1272839918:1272838917:=13,15c13,14%0a%3c Inter想到了一个折中的办法：把内存分段，并设计了4个段寄存器，CS，DS，ES和SS，分别用于指令、数据、其它和堆栈。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a%3c %0a%3c 这种寻址模式也就是“实地址模式”。在8086中，段寄存器还只是一个单纯的16位寄存器，而且操作寄存器的指令也不是特权指令。通过设置段寄存器和段内偏移，程序就可以访问整个物理内存，无安全性可言。%0a---%0a> Inter想到了一个折中的办法：设计了段寄存器。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a> %0a
host:1272839918=81.232.107.137
author:1272838917=
diff:1272838917:1272838542:=13,14c13%0a%3c Inter想到了一个折中的办法：设计了段寄存器。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址。不过段寄存器仍然是16位的，它的内容代表了段基址的高16位，这个16位的地址后面再加上4个0就构成20位的段基址。而原来的16位地址只是段内的偏移量。这样，一个完整的物理内存地址就由两部分组成，高16位的段基址和低16位的段内偏移量，当然它们有12位是重叠的，它们两部分相加在一起，才构成完整的物理地址。%0a%3c %0a---%0a> Inter想到了一个折中的办法：设计了段寄存器。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址，段寄存器也是16位的%0a
host:1272838917=81.232.107.137
author:1272838542=
diff:1272838542:1272837410:=10,13d9%0a%3c %0a%3c 地址总线宽度大于数据总线会带来一些麻烦，ALU无法在单个指令周期里完成对地址数据的运算。有一些容易想到的可行的办法，比如定义一个新的寄存器专门用于存放地址的高4位，但这样增加了计算的复杂性，程序员要增加成倍的汇编代码来操作地址数据而且无法保持兼容性。%0a%3c %0a%3c Inter想到了一个折中的办法：设计了段寄存器。把内存分为很多段，每一段有一个段基址，当然段基址也是一个20位的内存地址，段寄存器也是16位的%0a
host:1272838542=81.232.107.137
author:1272837410=
diff:1272837410:1272836965:=7c7%0a%3c 地址总线的宽度不一定要与ALU的宽度相同。因为ALU的宽度是固定的，它受限于当时的工艺水平，当时只能制造出16位的ALU；但地址总线不一样，它可以设计得更宽。地址总线的宽度如果与ALU相同当然是不错的办法，这样CPU的结构比较均衡，寻址可以在单个指令周期内完成，效率最高；而且从软件的解决来看，一个变量地址的长度可以用整型或者长整型来表示会比较方便。%0a---%0a> 地址总线的宽度不一定要与ALU的宽度相同。地址总线的宽度如果与ALU相同当然是不错的办法，这样CPU的结构比较均衡，寻址可以在单个指令周期内完成，效率最高；而且从软件的解决来看，一个变量地址的长度可以用整型或者长整型来表示会比较方便。%0a
host:1272837410=81.232.107.137
author:1272836965=
diff:1272836965:1272836581:=3,4c3,4%0a%3c 段寄存器的产生源于Inter 8086 CPU体系结构中数据总线与地址总线的宽度不一致。%0a%3c %0a---%0a> 段寄存器的产生源于8086CPU体系结构中数据总线与地址总线的宽度不一致。%0a> %0a9c9%0a%3c 但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了系统可寻址的范围，即可以支持多少内存。如果地址总线太窄的话，可寻址范围会很小。如果地址总线设计为16位的话，可寻址空间是2^16=64KB，这在当时被认为是不够的；Inter最终决定要让8086的地址空间为1M，也就是20位地址总线。%0a---%0a> 但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了%0a
host:1272836965=81.232.107.137
author:1272836581=
diff:1272836581:1272836581:=1,13d0%0a%3c 1 段寄存器的产生%0a%3c %0a%3c 段寄存器的产生源于8086CPU体系结构中数据总线与地址总线的宽度不一致。%0a%3c %0a%3c 数据总线的宽度，也即是ALU(算数逻辑单元)的宽度，平常说一个CPU是“16位”或者“32位”指的就是这个。8086CPU的数据总线是16位。%0a%3c %0a%3c 地址总线的宽度不一定要与ALU的宽度相同。地址总线的宽度如果与ALU相同当然是不错的办法，这样CPU的结构比较均衡，寻址可以在单个指令周期内完成，效率最高；而且从软件的解决来看，一个变量地址的长度可以用整型或者长整型来表示会比较方便。%0a%3c %0a%3c 但是，地址总线的宽度还要受制于需求，因为地址总线的宽度决定了%0a%3c %0a%3c 2 段寄存器的扩展%0a%3c %0a%3c 3 与页式存管并存%0a\ No newline at end of file%0a
host:1272836581=81.232.107.137
