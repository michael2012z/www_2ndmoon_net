version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319034302
host=117.89.207.43
name=DesignPattern.Command
rev=4
targets=DesignPattern.Command
text=\\%0a %0a[+++'''命令模式/Command'''+++]%0a%0a[+++''意图/适用场景：''+++]\\%0a命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。\\%0a每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是被谁处理、是否被处理、何时处理以及怎么处理。\\%0a命令模式有以下的优点：%0a# 允许请求方与接收方能够独立演化，使它们完全没有关系，只需要面向命令就可以了；%0a# 命令本身也容易演化，新的命令容易被加入系统；%0a# 接收请求的一方灵活性很大，可以选择接收与否，以及决定处理的细节；%0a# 容易设计一个命令队列；%0a# 可以容易地实现命令历史/日志功能。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Command/Command.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Command/Command.png]]%0a%0a[+++''参与者：''+++]%0a# 命令(Command)：所有命令的抽象接口。%0a# 具体命令(ConcreteCommand)：定义命令的具体内容。%0a# 递送者(Deliverer)：负责命令的递送过程。它从请求者那里接收命令，并把命令分发到合适的地方去。这一角色的灵活性比较大，它可以维护一个命令队列，可以记录命令历史。%0a# 请求者(Invoker)：命令的来源。%0a# 接收者(Receiver)：所有命令处理器的抽象接口。%0a# 具体接收者(ConcreteReceiver)：具体化Receiver接口，实现处理命令的具体功能。%0a%0a[+++''要点：''+++]\\%0a这里描述的命令模式与《Java与模式》和《设计模式》中描述的命令者不大相同。\\%0a命令模式最关键的概念是把请求者、接收者以及命令三方解耦合，但这两本书中所定义的模式结构以及给出的示例代码不够好。\\%0a这两书中实例的好处在于从结构上把三方解耦，每一个角色都可以面向接口编程，在实现进有很大的选择空间。\\%0a但是，它们互相之间仍然互相引用，不能说是完全解耦。一个更好的方法是引入一个递送者角色，它负责命令的分发以及队列的维护。这样，三方者不需要再互相引用。而且在时序上看，可以做到异步递送，扩展了系统的功能。%0a%0a[+++''应用实例：''+++]\\%0a这种命令/消息式的实例实在是太多。\\%0a还是看AWT的事件模式，在责任链模式里就讲过，一个事件产生后，会被依次分发给各个Listener去尝试处理，直到找到一个合适的处理者。\\%0a这里，可以想象有一个事件处理器，即Deliverer；产生事件的构件就是Invoker，它把事件交给Deliverer，就不再过问这个事件的处理过程了；Deliverer把事件交给第一个监听，也就是本模式中的Receiver，如果Receiver在handleEvent()中返回false，Deliverer还需要再找下一个Receiver。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteReceiver.java %0a%0apackage designPatterns.Command;%0a%0apublic class ConcreteReceiver implements Receiver {%0a	public void handle(Event e) {%0a		System.out.println("ConcreteReceiver.handle()");%0a	}%0a}%0a%0a%0a// Source code from file:  Deliverer.java %0a%0apackage designPatterns.Command;%0a%0apublic class Deliverer extends Thread {%0a	%0a	// This simulate a event queue, the length of the queue is 1 here.%0a	private Event queue = null;	%0a	private Receiver receiver = null;%0a	%0a	public Deliverer(Receiver receiver) {%0a		this.receiver = receiver;%0a	}%0a%0a	public void deliver(Event e) {%0a		queue = e;%0a	}%0a	%0a	public void distribute(Event e) {%0a		receiver.handle(e);%0a	}%0a%0a	public void run() {%0a		int count = 3;%0a		while (count-- > 0) {%0a			try {%0a				sleep(1000);%0a				if (null != queue) {%0a					distribute(queue);%0a					queue = null;%0a				}%0a			} catch (Exception e) {}%0a		}%0a	}%0a}%0a%0a%0a// Source code from file:  Event.java %0a%0apackage designPatterns.Command;%0a%0apublic class Event {%0a	int type;%0a	int parameterA;%0a	int parameterB;%0a}%0a%0a%0a// Source code from file:  Invoker.java %0a%0apackage designPatterns.Command;%0a%0apublic class Invoker {%0a	%0a	Deliverer deliverer = null;%0a	%0a	public Invoker(Deliverer deliverer) {%0a		this.deliverer = deliverer;%0a	}%0a	%0a	public void act() {%0a		Event e = new Event();%0a		deliverer.deliver(e);%0a	}%0a}%0a%0a%0a// Source code from file:  Receiver.java %0a%0apackage designPatterns.Command;%0a%0apublic interface Receiver {%0a	public void handle(Event e);%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Command;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Receiver receiver = new ConcreteReceiver();%0a		Deliverer deliverer = new Deliverer(receiver);%0a		deliverer.start();%0a		Invoker invoker = new Invoker(deliverer);%0a		invoker.act();%0a	}%0a}%0a(:sourcend:)
time=1319036984
author:1319036984=
diff:1319036984:1319035272:=16,17c16%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Command/Command.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Command/Command.png]]%0a%3c %0a---%0a>  %0a
host:1319036984=117.89.207.43
author:1319035272=
diff:1319035272:1319035248:=25c25,26%0a%3c [+++''要点：''+++]\\%0a---%0a> [+++''要点：''+++]%0a> %0a
host:1319035272=117.89.207.43
author:1319035248=
diff:1319035248:1319034302:=5,7c5,10%0a%3c [+++''意图/适用场景：''+++]\\%0a%3c 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。\\%0a%3c 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是被谁处理、是否被处理、何时处理以及怎么处理。\\%0a---%0a> [+++''意图/适用场景：''+++]%0a> %0a> 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。%0a> %0a> 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是被谁处理、是否被处理、何时处理以及怎么处理。%0a> %0a
host:1319035248=117.89.207.43
author:1319034302=
diff:1319034302:1319034302:=1,142d0%0a%3c \\%0a%3c  %0a%3c [+++'''命令模式/Command'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。%0a%3c %0a%3c 每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是被谁处理、是否被处理、何时处理以及怎么处理。%0a%3c %0a%3c 命令模式有以下的优点：%0a%3c # 允许请求方与接收方能够独立演化，使它们完全没有关系，只需要面向命令就可以了；%0a%3c # 命令本身也容易演化，新的命令容易被加入系统；%0a%3c # 接收请求的一方灵活性很大，可以选择接收与否，以及决定处理的细节；%0a%3c # 容易设计一个命令队列；%0a%3c # 可以容易地实现命令历史/日志功能。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 命令(Command)：所有命令的抽象接口。%0a%3c # 具体命令(ConcreteCommand)：定义命令的具体内容。%0a%3c # 递送者(Deliverer)：负责命令的递送过程。它从请求者那里接收命令，并把命令分发到合适的地方去。这一角色的灵活性比较大，它可以维护一个命令队列，可以记录命令历史。%0a%3c # 请求者(Invoker)：命令的来源。%0a%3c # 接收者(Receiver)：所有命令处理器的抽象接口。%0a%3c # 具体接收者(ConcreteReceiver)：具体化Receiver接口，实现处理命令的具体功能。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 这里描述的命令模式与《Java与模式》和《设计模式》中描述的命令者不大相同。\\%0a%3c 命令模式最关键的概念是把请求者、接收者以及命令三方解耦合，但这两本书中所定义的模式结构以及给出的示例代码不够好。\\%0a%3c 这两书中实例的好处在于从结构上把三方解耦，每一个角色都可以面向接口编程，在实现进有很大的选择空间。\\%0a%3c 但是，它们互相之间仍然互相引用，不能说是完全解耦。一个更好的方法是引入一个递送者角色，它负责命令的分发以及队列的维护。这样，三方者不需要再互相引用。而且在时序上看，可以做到异步递送，扩展了系统的功能。%0a%3c %0a%3c [+++''应用实例：''+++]\\%0a%3c 这种命令/消息式的实例实在是太多。\\%0a%3c 还是看AWT的事件模式，在责任链模式里就讲过，一个事件产生后，会被依次分发给各个Listener去尝试处理，直到找到一个合适的处理者。\\%0a%3c 这里，可以想象有一个事件处理器，即Deliverer；产生事件的构件就是Invoker，它把事件交给Deliverer，就不再过问这个事件的处理过程了；Deliverer把事件交给第一个监听，也就是本模式中的Receiver，如果Receiver在handleEvent()中返回false，Deliverer还需要再找下一个Receiver。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteReceiver.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public class ConcreteReceiver implements Receiver {%0a%3c 	public void handle(Event e) {%0a%3c 		System.out.println("ConcreteReceiver.handle()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Deliverer.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public class Deliverer extends Thread {%0a%3c 	%0a%3c 	// This simulate a event queue, the length of the queue is 1 here.%0a%3c 	private Event queue = null;	%0a%3c 	private Receiver receiver = null;%0a%3c 	%0a%3c 	public Deliverer(Receiver receiver) {%0a%3c 		this.receiver = receiver;%0a%3c 	}%0a%3c %0a%3c 	public void deliver(Event e) {%0a%3c 		queue = e;%0a%3c 	}%0a%3c 	%0a%3c 	public void distribute(Event e) {%0a%3c 		receiver.handle(e);%0a%3c 	}%0a%3c %0a%3c 	public void run() {%0a%3c 		int count = 3;%0a%3c 		while (count-- > 0) {%0a%3c 			try {%0a%3c 				sleep(1000);%0a%3c 				if (null != queue) {%0a%3c 					distribute(queue);%0a%3c 					queue = null;%0a%3c 				}%0a%3c 			} catch (Exception e) {}%0a%3c 		}%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Event.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public class Event {%0a%3c 	int type;%0a%3c 	int parameterA;%0a%3c 	int parameterB;%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Invoker.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public class Invoker {%0a%3c 	%0a%3c 	Deliverer deliverer = null;%0a%3c 	%0a%3c 	public Invoker(Deliverer deliverer) {%0a%3c 		this.deliverer = deliverer;%0a%3c 	}%0a%3c 	%0a%3c 	public void act() {%0a%3c 		Event e = new Event();%0a%3c 		deliverer.deliver(e);%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Receiver.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public interface Receiver {%0a%3c 	public void handle(Event e);%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Command;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Receiver receiver = new ConcreteReceiver();%0a%3c 		Deliverer deliverer = new Deliverer(receiver);%0a%3c 		deliverer.start();%0a%3c 		Invoker invoker = new Invoker(deliverer);%0a%3c 		invoker.act();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319034302=117.89.207.43
