version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319029568
host=180.109.20.194
name=DesignPattern.AbstractFactory
rev=5
targets=DesignPattern.AbstractFactory
text=\\%0a%0a[+++'''抽象工厂模式/Abstract Factory'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a抽象工厂模式适用于这样一种场景：%0a# 产品是成系列的，每一个系列的产品由多个不同的产品组成，这些产品有一些相似的特性，比如属于同一色系。%0a# 每一种产品又有很多种类，这些不同的产品可用一个产品继承树来表示。%0a# 系统中存在多个产品系列，但每次只需要产生一个系列出来工作，其它则不用。%0a# 总结以上的需求，产品类有这样的一种结构：%0a# 每一类产品有一个继承关系树，树上的子类是不同品种的产品。%0a# 所有产品类继承关系树的结构是完全一样的。%0a# 处在产品继承关系树相同位置的产品构成一个系列。%0a# 系统每次生产使用一个系列的产品。%0a%0a抽象工厂模式以这样的方式来支持这个系统中产品的生产：%0a* 定义一个与产品类继承关系树同样结构的生产者树，树上的每一个具体生产者子类负责生产一个产品系列中的所有具体产品。%0a%0a[+++''UML：''+++] %0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/AbstractFactory/AbstractFactory.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/AbstractFactory/AbstractFactory.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象产品(AbstractProduct)：为一类产品对象声明一个接口。%0a# 具体产品(ConcreteProduct)：定义一个将被相应的具体工厂创建的产品对象。实现AbstractProduct接口。%0a# 抽象工厂(AbstractFactory)：声明一个创建抽象产品对象的操作接口。%0a# 具体工厂(ConcreteFactory)：实现创建具体产品对象的操作。%0a%0a[+++''要点：''+++]%0a%0aAbstractFactory模式有下面的一些优点和缺点：%0a# 它分离了具体的类%0a** AbstractFactory模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。%0a# 它使得易于交换产品系列%0a** 一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。在我们的用户界面的例子中，我们仅需转换到相应的工厂对象并重新创建接口，就可实现从Motif窗口组件转换为PresentationManager窗口组件。%0a# 它有利于产品的一致性%0a** 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a# 难以扩展抽象工厂以生产新种类的产品%0a这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及AbstractFactory类及其所有子类的改变。我们会在实现一节讨论这个问题的一个解决办法。%0a%0a[+++''应用实例：''+++]%0a%0a试想一个支持多种外观风格的应用程序或者桌面套件。在它所支持的每一种外观风格中，Button和Scrollbar等组件都是不一样的，它们都是单独的产品。但是所有的Button都继承于一个公共的AbstractButton，而所有的Scrollbar也都处在一个继承树结构中；对某一个外观风格而言，它所选取的每一个组件都处在其产品树的同一位置上。%0a%0a这时就可以定义一个工厂树，它的结构与每一个组件的树结构相同，一个工厂类就负责生产一种外观风格的所有组件产品。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteCreatorA.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ConcreteCreatorA implements Creator {%0a%0a	public ProductI createProductI() {%0a		return new ProductIA();%0a	}%0a%0a	public ProductII createProductII() {%0a		return new ProductIIA();%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ConcreteCreatorB.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ConcreteCreatorB implements Creator {%0a%0a	public ProductI createProductI() {%0a		return new ProductIB();%0a	}%0a%0a	public ProductII createProductII() {%0a		return new ProductIIB();%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Creator.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic interface Creator {%0a	public ProductI createProductI();%0a	public ProductII createProductII();%0a}%0a%0a%0a// Source code from file:  ProductI.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic interface ProductI {%0a%0a}%0a%0a%0a// Source code from file:  ProductIA.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ProductIA implements ProductI {%0a%0a}%0a%0a%0a// Source code from file:  ProductIB.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ProductIB implements ProductI {%0a%0a}%0a%0a%0a// Source code from file:  ProductII.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic interface ProductII {%0a%0a}%0a%0a%0a// Source code from file:  ProductIIA.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ProductIIA implements ProductII {%0a%0a}%0a%0a%0a// Source code from file:  ProductIIB.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class ProductIIB implements ProductII {%0a%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.AbstractFactory;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Creator creator = null;%0a		// now create product series A%0a		creator = new ConcreteCreatorA();%0a		creator.createProductI();%0a		creator.createProductII();%0a		// now create product series B%0a		creator = new ConcreteCreatorB();%0a		creator.createProductI();%0a		creator.createProductII();%0a	}%0a}%0a(:sourcend:)
time=1319382146
author:1319382146=
diff:1319382146:1319036096:=30d29%0a%3c %0a
host:1319382146=180.109.20.194
author:1319036096=
diff:1319036096:1319029631:=21d20%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/AbstractFactory/AbstractFactory.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/AbstractFactory/AbstractFactory.png]]%0a
host:1319036096=117.89.207.43
author:1319029631=
diff:1319029631:1319029609:=35c35%0a%3c ** 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a---%0a> * 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a
host:1319029631=117.89.207.43
author:1319029609=
diff:1319029609:1319029568:=6d5%0a%3c %0a35c34%0a%3c * 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a---%0a> 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a40d38%0a%3c %0a
host:1319029609=117.89.207.43
author:1319029568=
diff:1319029568:1319029568:=1,160d0%0a%3c \\%0a%3c %0a%3c [+++'''抽象工厂模式/Abstract Factory'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c 抽象工厂模式适用于这样一种场景：%0a%3c # 产品是成系列的，每一个系列的产品由多个不同的产品组成，这些产品有一些相似的特性，比如属于同一色系。%0a%3c # 每一种产品又有很多种类，这些不同的产品可用一个产品继承树来表示。%0a%3c # 系统中存在多个产品系列，但每次只需要产生一个系列出来工作，其它则不用。%0a%3c # 总结以上的需求，产品类有这样的一种结构：%0a%3c # 每一类产品有一个继承关系树，树上的子类是不同品种的产品。%0a%3c # 所有产品类继承关系树的结构是完全一样的。%0a%3c # 处在产品继承关系树相同位置的产品构成一个系列。%0a%3c # 系统每次生产使用一个系列的产品。%0a%3c %0a%3c 抽象工厂模式以这样的方式来支持这个系统中产品的生产：%0a%3c * 定义一个与产品类继承关系树同样结构的生产者树，树上的每一个具体生产者子类负责生产一个产品系列中的所有具体产品。%0a%3c %0a%3c [+++''UML：''+++] %0a%3c %0a%3c [+++''参与者：''+++]%0a%3c # 抽象产品(AbstractProduct)：为一类产品对象声明一个接口。%0a%3c # 具体产品(ConcreteProduct)：定义一个将被相应的具体工厂创建的产品对象。实现AbstractProduct接口。%0a%3c # 抽象工厂(AbstractFactory)：声明一个创建抽象产品对象的操作接口。%0a%3c # 具体工厂(ConcreteFactory)：实现创建具体产品对象的操作。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c AbstractFactory模式有下面的一些优点和缺点：%0a%3c # 它分离了具体的类%0a%3c ** AbstractFactory模式帮助你控制一个应用创建的对象的类。因为一个工厂封装创建产品对象的责任和过程，它将客户与类的实现分离。客户通过它们的抽象接口操纵实例。产品的类名也在具体工厂的实现中被分离；它们不出现在客户代码中。%0a%3c # 它使得易于交换产品系列%0a%3c ** 一个具体工厂类在一个应用中仅出现一次—即在它初始化的时候。这使得改变一个应用的具体工厂变得很容易。它只需改变具体的工厂即可使用不同的产品配置，这是因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。在我们的用户界面的例子中，我们仅需转换到相应的工厂对象并重新创建接口，就可实现从Motif窗口组件转换为PresentationManager窗口组件。%0a%3c # 它有利于产品的一致性%0a%3c 当一个系列中的产品对象被设计成一起工作时，一个应用一次只能使用同一个系列中的对象，这一点很重要。而AbstractFactory很容易实现这一点。%0a%3c # 难以扩展抽象工厂以生产新种类的产品%0a%3c 这是因为AbstractFactory接口确定了可以被创建的产品集合。支持新种类的产品就需要扩展该工厂接口，这将涉及AbstractFactory类及其所有子类的改变。我们会在实现一节讨论这个问题的一个解决办法。%0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c 试想一个支持多种外观风格的应用程序或者桌面套件。在它所支持的每一种外观风格中，Button和Scrollbar等组件都是不一样的，它们都是单独的产品。但是所有的Button都继承于一个公共的AbstractButton，而所有的Scrollbar也都处在一个继承树结构中；对某一个外观风格而言，它所选取的每一个组件都处在其产品树的同一位置上。%0a%3c %0a%3c 这时就可以定义一个工厂树，它的结构与每一个组件的树结构相同，一个工厂类就负责生产一种外观风格的所有组件产品。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteCreatorA.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ConcreteCreatorA implements Creator {%0a%3c %0a%3c 	public ProductI createProductI() {%0a%3c 		return new ProductIA();%0a%3c 	}%0a%3c %0a%3c 	public ProductII createProductII() {%0a%3c 		return new ProductIIA();%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteCreatorB.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ConcreteCreatorB implements Creator {%0a%3c %0a%3c 	public ProductI createProductI() {%0a%3c 		return new ProductIB();%0a%3c 	}%0a%3c %0a%3c 	public ProductII createProductII() {%0a%3c 		return new ProductIIB();%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Creator.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public interface Creator {%0a%3c 	public ProductI createProductI();%0a%3c 	public ProductII createProductII();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductI.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public interface ProductI {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductIA.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ProductIA implements ProductI {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductIB.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ProductIB implements ProductI {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductII.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public interface ProductII {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductIIA.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ProductIIA implements ProductII {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ProductIIB.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class ProductIIB implements ProductII {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.AbstractFactory;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Creator creator = null;%0a%3c 		// now create product series A%0a%3c 		creator = new ConcreteCreatorA();%0a%3c 		creator.createProductI();%0a%3c 		creator.createProductII();%0a%3c 		// now create product series B%0a%3c 		creator = new ConcreteCreatorB();%0a%3c 		creator.createProductI();%0a%3c 		creator.createProductII();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319029568=117.89.207.43
