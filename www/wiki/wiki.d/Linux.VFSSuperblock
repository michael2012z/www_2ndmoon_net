version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2
author=
charset=UTF-8
csum=
ctime=1322491304
host=1.202.198.162
name=Linux.VFSSuperblock
rev=4
targets=Linux.VFSSuperblock
text=!! Super Block%0a%0aThe superblock gives global information on a filesystem: the device on which it lives, its block size, its type, the dentry of the root of the filesystem, the methods it has, etc., etc.%0a%0a(:source lang=c:)%0astruct super_block {%0a	struct list_head	s_list;		/* Keep this first */%0a	dev_t			s_dev;		/* search index; _not_ kdev_t */%0a	unsigned char		s_dirt;%0a	unsigned char		s_blocksize_bits;%0a	unsigned long		s_blocksize;%0a	loff_t			s_maxbytes;	/* Max file size */%0a	struct file_system_type	*s_type;%0a	const struct super_operations	*s_op;%0a	const struct dquot_operations	*dq_op;%0a	const struct quotactl_ops	*s_qcop;%0a	const struct export_operations *s_export_op;%0a	unsigned long		s_flags;%0a	unsigned long		s_magic;%0a	struct dentry		*s_root;%0a	struct rw_semaphore	s_umount;%0a	struct mutex		s_lock;%0a	int			s_count;%0a	atomic_t		s_active;%0a#ifdef CONFIG_SECURITY%0a	void                    *s_security;%0a#endif%0a	const struct xattr_handler **s_xattr;%0a%0a	struct list_head	s_inodes;	/* all inodes */%0a	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */%0a#ifdef CONFIG_SMP%0a	struct list_head __percpu *s_files;%0a#else%0a	struct list_head	s_files;%0a#endif%0a	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */%0a	struct list_head	s_dentry_lru;	/* unused dentry lru */%0a	int			s_nr_dentry_unused;	/* # of dentry on lru */%0a%0a	/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */%0a	spinlock_t		s_inode_lru_lock ____cacheline_aligned_in_smp;%0a	struct list_head	s_inode_lru;		/* unused inode lru */%0a	int			s_nr_inodes_unused;	/* # of inodes on lru */%0a%0a	struct block_device	*s_bdev;%0a	struct backing_dev_info *s_bdi;%0a	struct mtd_info		*s_mtd;%0a	struct list_head	s_instances;%0a	struct quota_info	s_dquot;	/* Diskquota specific options */%0a%0a	int			s_frozen;%0a	wait_queue_head_t	s_wait_unfrozen;%0a%0a	char s_id[32];				/* Informational name */%0a	u8 s_uuid[16];				/* UUID */%0a%0a	void 			*s_fs_info;	/* Filesystem private info */%0a	fmode_t			s_mode;%0a%0a	/* Granularity of c/m/atime in ns.%0a	   Cannot be worse than a second */%0a	u32		   s_time_gran;%0a%0a	/*%0a	 * The next field is for VFS *only*. No filesystems have any business%0a	 * even looking at it. You had been warned.%0a	 */%0a	struct mutex s_vfs_rename_mutex;	/* Kludge */%0a%0a	/*%0a	 * Filesystem subtype.  If non-empty the filesystem type field%0a	 * in /proc/mounts will be "type.subtype"%0a	 */%0a	char *s_subtype;%0a%0a	/*%0a	 * Saved mount options for lazy filesystems using%0a	 * generic_show_options()%0a	 */%0a	char __rcu *s_options;%0a	const struct dentry_operations *s_d_op; /* default d_op for dentries */%0a%0a	/*%0a	 * Saved pool identifier for cleancache (-1 means none)%0a	 */%0a	int cleancache_poolid;%0a%0a	struct shrinker s_shrink;	/* per-sb shrinker handle */%0a};%0a(:sourcend:)%0a%0a(:source lang=c:)%0astruct super_operations {%0a   	struct inode *(*alloc_inode)(struct super_block *sb);%0a	void (*destroy_inode)(struct inode *);%0a%0a   	void (*dirty_inode) (struct inode *, int flags);%0a	int (*write_inode) (struct inode *, struct writeback_control *wbc);%0a	int (*drop_inode) (struct inode *);%0a	void (*evict_inode) (struct inode *);%0a	void (*put_super) (struct super_block *);%0a	void (*write_super) (struct super_block *);%0a	int (*sync_fs)(struct super_block *sb, int wait);%0a	int (*freeze_fs) (struct super_block *);%0a	int (*unfreeze_fs) (struct super_block *);%0a	int (*statfs) (struct dentry *, struct kstatfs *);%0a	int (*remount_fs) (struct super_block *, int *, char *);%0a	void (*umount_begin) (struct super_block *);%0a%0a	int (*show_options)(struct seq_file *, struct vfsmount *);%0a	int (*show_devname)(struct seq_file *, struct vfsmount *);%0a	int (*show_path)(struct seq_file *, struct vfsmount *);%0a	int (*show_stats)(struct seq_file *, struct vfsmount *);%0a#ifdef CONFIG_QUOTA%0a	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);%0a	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);%0a#endif%0a	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);%0a	int (*nr_cached_objects)(struct super_block *);%0a	void (*free_cached_objects)(struct super_block *, int);%0a};%0a(:sourcend:)%0a%0aThis is enough to get started: the dentry of the root directory tells us the inode of this root directory (and in particular its i_ino), and sb->s_op->read_inode(inode) will read this inode from disk. Now inode->i_op->lookup() allows us to find names in the root directory, etc.%0a%0aEach superblock is on six lists, with links through the fields s_list, s_dirty, s_io, s_anon, s_files, s_instances, respectively.%0a%0a!!! The super_blocks list%0a%0aAll superblocks are collected in a list super_blocks with links in the fields s_list. This list is protected by the spinlock sb_lock. The main use is in super.c:get_super() or user_get_super() to find the superblock for a given block device. (Both routines are identical, except that one takes a bdev, the other a dev_t.) This list is also used various places where all superblocks must be sync'ed or all dirty inodes must be written out.%0a%0a!!! The fs_supers list%0a%0aAll superblocks of a given type are collected in a list headed by the fs_supers field of the struct filesystem_type, with links in the fields s_instances. Also this list is protected by the spinlock sb_lock. See above.%0a%0a!!! The file list%0a%0aAll open files belonging to a given superblock are chained in a list headed by the s_files field of the superblock, with links in the fields f_list of the files. These lists are protected by the spinlock files_lock. This list is used for example in fs_may_remount_ro() to check that there are no files currently open for writing. See also below.%0a%0a!!! The list of anonymous dentries%0a%0aNormally, all dentries are connected to root. However, when NFS filehandles are used this need not be the case. Dentries that are roots of subtrees potentially unconnected to root are chained in a list headed by the s_anon field of the superblock, with links in the fields d_hash. These lists are protected by the spinlock dcache_lock. They are grown in dcache.c:d_alloc_anon() and shrunk in super.c:generic_shutdown_super(). See the discussion in Documentation/filesystems/Exporting.%0a%0a!!! The inode lists s_dirty, s_io%0a%0aLists of inodes to be written out. These lists are headed at the s_dirty (resp. s_io) field of the superblock, with links in the fields i_list. These lists are protected by the spinlock inode_lock. See fs/fs-writeback.c.%0a
time=1322542319
author:1322542319=
diff:1322542319:1322542281:=1,2d0%0a%3c !! Super Block%0a%3c %0a
host:1322542319=1.202.198.162
author:1322542281=
diff:1322542281:1322542039:=1,2d0%0a%3c The superblock gives global information on a filesystem: the device on which it lives, its block size, its type, the dentry of the root of the filesystem, the methods it has, etc., etc.%0a%3c %0a122,145d119%0a%3c %0a%3c This is enough to get started: the dentry of the root directory tells us the inode of this root directory (and in particular its i_ino), and sb->s_op->read_inode(inode) will read this inode from disk. Now inode->i_op->lookup() allows us to find names in the root directory, etc.%0a%3c %0a%3c Each superblock is on six lists, with links through the fields s_list, s_dirty, s_io, s_anon, s_files, s_instances, respectively.%0a%3c %0a%3c !!! The super_blocks list%0a%3c %0a%3c All superblocks are collected in a list super_blocks with links in the fields s_list. This list is protected by the spinlock sb_lock. The main use is in super.c:get_super() or user_get_super() to find the superblock for a given block device. (Both routines are identical, except that one takes a bdev, the other a dev_t.) This list is also used various places where all superblocks must be sync'ed or all dirty inodes must be written out.%0a%3c %0a%3c !!! The fs_supers list%0a%3c %0a%3c All superblocks of a given type are collected in a list headed by the fs_supers field of the struct filesystem_type, with links in the fields s_instances. Also this list is protected by the spinlock sb_lock. See above.%0a%3c %0a%3c !!! The file list%0a%3c %0a%3c All open files belonging to a given superblock are chained in a list headed by the s_files field of the superblock, with links in the fields f_list of the files. These lists are protected by the spinlock files_lock. This list is used for example in fs_may_remount_ro() to check that there are no files currently open for writing. See also below.%0a%3c %0a%3c !!! The list of anonymous dentries%0a%3c %0a%3c Normally, all dentries are connected to root. However, when NFS filehandles are used this need not be the case. Dentries that are roots of subtrees potentially unconnected to root are chained in a list headed by the s_anon field of the superblock, with links in the fields d_hash. These lists are protected by the spinlock dcache_lock. They are grown in dcache.c:d_alloc_anon() and shrunk in super.c:generic_shutdown_super(). See the discussion in Documentation/filesystems/Exporting.%0a%3c %0a%3c !!! The inode lists s_dirty, s_io%0a%3c %0a%3c Lists of inodes to be written out. These lists are headed at the s_dirty (resp. s_io) field of the superblock, with links in the fields i_list. These lists are protected by the spinlock inode_lock. See fs/fs-writeback.c.%0a
host:1322542281=1.202.198.162
author:1322542039=
diff:1322542039:1322491304:=1a2%0a> %0a87,119c88,89%0a%3c (:sourcend:)%0a%3c %0a%3c (:source lang=c:)%0a%3c struct super_operations {%0a%3c    	struct inode *(*alloc_inode)(struct super_block *sb);%0a%3c 	void (*destroy_inode)(struct inode *);%0a%3c %0a%3c    	void (*dirty_inode) (struct inode *, int flags);%0a%3c 	int (*write_inode) (struct inode *, struct writeback_control *wbc);%0a%3c 	int (*drop_inode) (struct inode *);%0a%3c 	void (*evict_inode) (struct inode *);%0a%3c 	void (*put_super) (struct super_block *);%0a%3c 	void (*write_super) (struct super_block *);%0a%3c 	int (*sync_fs)(struct super_block *sb, int wait);%0a%3c 	int (*freeze_fs) (struct super_block *);%0a%3c 	int (*unfreeze_fs) (struct super_block *);%0a%3c 	int (*statfs) (struct dentry *, struct kstatfs *);%0a%3c 	int (*remount_fs) (struct super_block *, int *, char *);%0a%3c 	void (*umount_begin) (struct super_block *);%0a%3c %0a%3c 	int (*show_options)(struct seq_file *, struct vfsmount *);%0a%3c 	int (*show_devname)(struct seq_file *, struct vfsmount *);%0a%3c 	int (*show_path)(struct seq_file *, struct vfsmount *);%0a%3c 	int (*show_stats)(struct seq_file *, struct vfsmount *);%0a%3c #ifdef CONFIG_QUOTA%0a%3c 	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);%0a%3c 	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);%0a%3c #endif%0a%3c 	int (*bdev_try_to_free_page)(struct super_block*, struct page*, gfp_t);%0a%3c 	int (*nr_cached_objects)(struct super_block *);%0a%3c 	void (*free_cached_objects)(struct super_block *, int);%0a%3c };%0a%3c (:sourcend:)%0a---%0a> %0a> (:sourcend:)%0a\ No newline at end of file%0a
host:1322542039=1.202.198.162
author:1322491304=
diff:1322491304:1322491304:=1,89d0%0a%3c (:source lang=c:)%0a%3c %0a%3c struct super_block {%0a%3c 	struct list_head	s_list;		/* Keep this first */%0a%3c 	dev_t			s_dev;		/* search index; _not_ kdev_t */%0a%3c 	unsigned char		s_dirt;%0a%3c 	unsigned char		s_blocksize_bits;%0a%3c 	unsigned long		s_blocksize;%0a%3c 	loff_t			s_maxbytes;	/* Max file size */%0a%3c 	struct file_system_type	*s_type;%0a%3c 	const struct super_operations	*s_op;%0a%3c 	const struct dquot_operations	*dq_op;%0a%3c 	const struct quotactl_ops	*s_qcop;%0a%3c 	const struct export_operations *s_export_op;%0a%3c 	unsigned long		s_flags;%0a%3c 	unsigned long		s_magic;%0a%3c 	struct dentry		*s_root;%0a%3c 	struct rw_semaphore	s_umount;%0a%3c 	struct mutex		s_lock;%0a%3c 	int			s_count;%0a%3c 	atomic_t		s_active;%0a%3c #ifdef CONFIG_SECURITY%0a%3c 	void                    *s_security;%0a%3c #endif%0a%3c 	const struct xattr_handler **s_xattr;%0a%3c %0a%3c 	struct list_head	s_inodes;	/* all inodes */%0a%3c 	struct hlist_bl_head	s_anon;		/* anonymous dentries for (nfs) exporting */%0a%3c #ifdef CONFIG_SMP%0a%3c 	struct list_head __percpu *s_files;%0a%3c #else%0a%3c 	struct list_head	s_files;%0a%3c #endif%0a%3c 	/* s_dentry_lru, s_nr_dentry_unused protected by dcache.c lru locks */%0a%3c 	struct list_head	s_dentry_lru;	/* unused dentry lru */%0a%3c 	int			s_nr_dentry_unused;	/* # of dentry on lru */%0a%3c %0a%3c 	/* s_inode_lru_lock protects s_inode_lru and s_nr_inodes_unused */%0a%3c 	spinlock_t		s_inode_lru_lock ____cacheline_aligned_in_smp;%0a%3c 	struct list_head	s_inode_lru;		/* unused inode lru */%0a%3c 	int			s_nr_inodes_unused;	/* # of inodes on lru */%0a%3c %0a%3c 	struct block_device	*s_bdev;%0a%3c 	struct backing_dev_info *s_bdi;%0a%3c 	struct mtd_info		*s_mtd;%0a%3c 	struct list_head	s_instances;%0a%3c 	struct quota_info	s_dquot;	/* Diskquota specific options */%0a%3c %0a%3c 	int			s_frozen;%0a%3c 	wait_queue_head_t	s_wait_unfrozen;%0a%3c %0a%3c 	char s_id[32];				/* Informational name */%0a%3c 	u8 s_uuid[16];				/* UUID */%0a%3c %0a%3c 	void 			*s_fs_info;	/* Filesystem private info */%0a%3c 	fmode_t			s_mode;%0a%3c %0a%3c 	/* Granularity of c/m/atime in ns.%0a%3c 	   Cannot be worse than a second */%0a%3c 	u32		   s_time_gran;%0a%3c %0a%3c 	/*%0a%3c 	 * The next field is for VFS *only*. No filesystems have any business%0a%3c 	 * even looking at it. You had been warned.%0a%3c 	 */%0a%3c 	struct mutex s_vfs_rename_mutex;	/* Kludge */%0a%3c %0a%3c 	/*%0a%3c 	 * Filesystem subtype.  If non-empty the filesystem type field%0a%3c 	 * in /proc/mounts will be "type.subtype"%0a%3c 	 */%0a%3c 	char *s_subtype;%0a%3c %0a%3c 	/*%0a%3c 	 * Saved mount options for lazy filesystems using%0a%3c 	 * generic_show_options()%0a%3c 	 */%0a%3c 	char __rcu *s_options;%0a%3c 	const struct dentry_operations *s_d_op; /* default d_op for dentries */%0a%3c %0a%3c 	/*%0a%3c 	 * Saved pool identifier for cleancache (-1 means none)%0a%3c 	 */%0a%3c 	int cleancache_poolid;%0a%3c %0a%3c 	struct shrinker s_shrink;	/* per-sb shrinker handle */%0a%3c };%0a%3c %0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1322491304=58.212.192.21
