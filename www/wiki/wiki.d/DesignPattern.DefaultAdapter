version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319031552
host=117.89.207.43
name=DesignPattern.DefaultAdapter
rev=2
targets=DesignPattern.DefaultAdapter
text=\\%0a%0a[+++'''缺省适配模式/Default Adapter'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a缺省适配模式为一个接口提供缺省实现，这样了类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。%0a%0a当原接口中定义的方法太多，而其中大部分又不被需要时，这种模式非常实用。由缺省适配器类直接实现接口，并为所有方法提供缺省的空实现。用户类就只需要继承适配器类，只实现感兴趣的方法就行了。%0a%0aJava的WindowAdapter就是一个典型的缺少适配器类。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/DefaultAdapter/DefaultAdapter.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/DefaultAdapter/DefaultAdapter.png]]%0a%0a[+++''参与者：''+++]%0a# Target：目标接口。可能定义有很多方法，但这些方法不一定全都被用户类所需要。%0a# Adapter：缺少适配模式的核心。它实现Target接口，为所有方法提供空的实现。%0a# User：用户类，它需要实现Target接口。但因为Target方法众多，而User中对其中一两个感兴趣。如果直接实现Target，就需要提供众多的空方法。所以它继承Adapter，只需要重写它感兴趣的方法即可。既实现了Target接口，又省去了定义空方法的麻烦。%0a%0a[+++''相关模式：''+++]%0a%0a同名为“适配器”的模式，但适配器模式的用意是改变Adaptee接口，使它与目标接口Target相容；而缺省适配模式只是为方便实现复杂接口而定义一种平庸实现。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Adapter.java %0a%0apackage designPatterns.DefaultAdapter;%0a%0apublic class Adapter implements Target {%0a%0a	public void operation1() {%0a	}%0a%0a	public void operation2() {%0a	}%0a%0a	public void operation3() {%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Target.java %0a%0apackage designPatterns.DefaultAdapter;%0a%0apublic interface Target {%0a	public void operation1();%0a	public void operation2();%0a	public void operation3();%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.DefaultAdapter;%0a%0apublic class User extends Adapter {%0a	public void operation2() {%0a		System.out.println("User.operation2()");%0a	}%0a	%0a	public static void main(String [] args) {%0a		Target target = new User();%0a		target.operation1();%0a		target.operation2();%0a		target.operation3();%0a	}%0a}%0a(:sourcend:)
time=1319036347
author:1319036347=
diff:1319036347:1319031552:=14,15c14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/DefaultAdapter/DefaultAdapter.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/DefaultAdapter/DefaultAdapter.png]]%0a%3c %0a---%0a>  %0a
host:1319036347=117.89.207.43
author:1319031552=
diff:1319031552:1319031552:=1,71d0%0a%3c \\%0a%3c %0a%3c [+++'''缺省适配模式/Default Adapter'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 缺省适配模式为一个接口提供缺省实现，这样了类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。%0a%3c %0a%3c 当原接口中定义的方法太多，而其中大部分又不被需要时，这种模式非常实用。由缺省适配器类直接实现接口，并为所有方法提供缺省的空实现。用户类就只需要继承适配器类，只实现感兴趣的方法就行了。%0a%3c %0a%3c Java的WindowAdapter就是一个典型的缺少适配器类。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # Target：目标接口。可能定义有很多方法，但这些方法不一定全都被用户类所需要。%0a%3c # Adapter：缺少适配模式的核心。它实现Target接口，为所有方法提供空的实现。%0a%3c # User：用户类，它需要实现Target接口。但因为Target方法众多，而User中对其中一两个感兴趣。如果直接实现Target，就需要提供众多的空方法。所以它继承Adapter，只需要重写它感兴趣的方法即可。既实现了Target接口，又省去了定义空方法的麻烦。%0a%3c %0a%3c [+++''相关模式：''+++]%0a%3c %0a%3c 同名为“适配器”的模式，但适配器模式的用意是改变Adaptee接口，使它与目标接口Target相容；而缺省适配模式只是为方便实现复杂接口而定义一种平庸实现。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Adapter.java %0a%3c %0a%3c package designPatterns.DefaultAdapter;%0a%3c %0a%3c public class Adapter implements Target {%0a%3c %0a%3c 	public void operation1() {%0a%3c 	}%0a%3c %0a%3c 	public void operation2() {%0a%3c 	}%0a%3c %0a%3c 	public void operation3() {%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Target.java %0a%3c %0a%3c package designPatterns.DefaultAdapter;%0a%3c %0a%3c public interface Target {%0a%3c 	public void operation1();%0a%3c 	public void operation2();%0a%3c 	public void operation3();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.DefaultAdapter;%0a%3c %0a%3c public class User extends Adapter {%0a%3c 	public void operation2() {%0a%3c 		System.out.println("User.operation2()");%0a%3c 	}%0a%3c 	%0a%3c 	public static void main(String [] args) {%0a%3c 		Target target = new User();%0a%3c 		target.operation1();%0a%3c 		target.operation2();%0a%3c 		target.operation3();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319031552=117.89.207.43
