version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319029166
host=117.89.207.43
name=DesignPattern.FactoryMethod
rev=5
targets=DesignPattern.FactoryMethod
text=\\%0a%0a[+++'''工厂方法模式/Factory Method'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a工厂类定义一个用于创建产品对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。%0a%0a这一模式的特征是工厂类的子类继承树与产品类的子类继承树有一一对应的关系。%0a%0a在下列情况下可以使用Factory Method模式：%0a# 当一个类不知道它所必须创建的对象的类的时候。%0a# 当一个类希望由它的子类来指定它所创建的对象的时候。%0a# 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。%0a%0a[+++''UML：''+++]%0a %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/FactoryMethod/FactoryMethod.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/FactoryMethod/FactoryMethod.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象产品(Product)：定义工厂方法所创建的对象的接口。%0a# 具体产品(ConcreteProduct）：实现Product接口。%0a# 抽象工厂类(Creator）：声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。可以调用工厂方法以创建一个Product对象。%0a# 具体工厂类(ConcreteCreator）：重定义工厂方法以返回一个ConcreteProduct实例。%0a%0a[+++''应用实例：''+++]%0a%0a考虑这样一个应用框架，两个主要的抽象是类Application和Document。这两个类都是抽象的，客户必须通过它们的子类来做与具体应用相关的实现。例如，为创建一个绘图应用，我们定义类DrawingApplication和DrawingDocument。%0a%0aApplication类负责管理Document并根据需要创建它们—例如，当用户从菜单中选择Open或New的时候。因为被实例化的特定Document子类是与特定应用相关的，所以Application类不可能预测到哪个Document子类将被实例化—Application类仅知道一个新的文档何时应被创建，而不知道哪一种Document将被创建。这就产生了一个尴尬的局面：框架必须实例化类，但是它只知道不能被实例化的抽象类。%0a%0aFactory Method模式提供了一个解决办案。它封装了哪一个Document子类将被创建的信息并将这些信息从该框架中分离出来。Document继承树与Application继承树具有同样的结构，是一一对应的关系。%0a%0aApplication的子类重定义Application的抽象操作CreateDocument以返回适当的Document子类对象。一旦一个Application子类实例化以后，它就可以实例化与应用相关的文档，而无需知道这些文档的类。我们称CreateDocument是一个工厂方法（Factory Method），因为它负责“生产”一个对象。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteCreatorA.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic class ConcreteCreatorA implements Creator {%0a	public Product factory() {%0a		return new ConcreteProductA();%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteCreatorB.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic class ConcreteCreatorB implements Creator {%0a	public Product factory() {%0a		return new ConcreteProductB();%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteProductA.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic class ConcreteProductA implements Product {%0a%0a}%0a%0a%0a// Source code from file:  ConcreteProductB.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic class ConcreteProductB implements Product {%0a%0a}%0a%0a%0a// Source code from file:  Creator.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic interface Creator {%0a	public Product factory();%0a}%0a%0a%0a// Source code from file:  Product.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic interface Product {%0a%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.FactoryMethod;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Creator creatorA = new ConcreteCreatorA();%0a		Creator creatorB = new ConcreteCreatorB();%0a		Product product = creatorA.factory();%0a		System.out.println(product);%0a		product = creatorB.factory();%0a		System.out.println(product);%0a	}%0a}%0a(:sourcend:)
time=1319036054
author:1319036054=
diff:1319036054:1319029262:=17,18c17%0a%3c  %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/FactoryMethod/FactoryMethod.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/FactoryMethod/FactoryMethod.png]]%0a%3c %0a---%0a>  %0a
host:1319036054=117.89.207.43
author:1319029262=
diff:1319029262:1319029231:=24c24,26%0a%3c [+++''应用实例：''+++]%0a---%0a> [+++''扩展：''+++]%0a> %0a> 应用实例：%0a
host:1319029262=117.89.207.43
author:1319029231=
diff:1319029231:1319029208:=18a19%0a> %0a
host:1319029231=117.89.207.43
author:1319029208=
diff:1319029208:1319029166:=11c11%0a%3c 在下列情况下可以使用Factory Method模式：%0a---%0a> 在下列情况下可以使用Factory Method模式：\\%0a
host:1319029208=117.89.207.43
author:1319029166=
diff:1319029166:1319029166:=1,111d0%0a%3c \\%0a%3c %0a%3c [+++'''工厂方法模式/Factory Method'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 工厂类定义一个用于创建产品对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。%0a%3c %0a%3c 这一模式的特征是工厂类的子类继承树与产品类的子类继承树有一一对应的关系。%0a%3c %0a%3c 在下列情况下可以使用Factory Method模式：\\%0a%3c # 当一个类不知道它所必须创建的对象的类的时候。%0a%3c # 当一个类希望由它的子类来指定它所创建的对象的时候。%0a%3c # 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c %0a%3c # 抽象产品(Product)：定义工厂方法所创建的对象的接口。%0a%3c # 具体产品(ConcreteProduct）：实现Product接口。%0a%3c # 抽象工厂类(Creator）：声明工厂方法，该方法返回一个Product类型的对象。Creator也可以定义一个工厂方法的缺省实现，它返回一个缺省的ConcreteProduct对象。可以调用工厂方法以创建一个Product对象。%0a%3c # 具体工厂类(ConcreteCreator）：重定义工厂方法以返回一个ConcreteProduct实例。%0a%3c %0a%3c [+++''扩展：''+++]%0a%3c %0a%3c 应用实例：%0a%3c %0a%3c 考虑这样一个应用框架，两个主要的抽象是类Application和Document。这两个类都是抽象的，客户必须通过它们的子类来做与具体应用相关的实现。例如，为创建一个绘图应用，我们定义类DrawingApplication和DrawingDocument。%0a%3c %0a%3c Application类负责管理Document并根据需要创建它们—例如，当用户从菜单中选择Open或New的时候。因为被实例化的特定Document子类是与特定应用相关的，所以Application类不可能预测到哪个Document子类将被实例化—Application类仅知道一个新的文档何时应被创建，而不知道哪一种Document将被创建。这就产生了一个尴尬的局面：框架必须实例化类，但是它只知道不能被实例化的抽象类。%0a%3c %0a%3c Factory Method模式提供了一个解决办案。它封装了哪一个Document子类将被创建的信息并将这些信息从该框架中分离出来。Document继承树与Application继承树具有同样的结构，是一一对应的关系。%0a%3c %0a%3c Application的子类重定义Application的抽象操作CreateDocument以返回适当的Document子类对象。一旦一个Application子类实例化以后，它就可以实例化与应用相关的文档，而无需知道这些文档的类。我们称CreateDocument是一个工厂方法（Factory Method），因为它负责“生产”一个对象。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteCreatorA.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public class ConcreteCreatorA implements Creator {%0a%3c 	public Product factory() {%0a%3c 		return new ConcreteProductA();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteCreatorB.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public class ConcreteCreatorB implements Creator {%0a%3c 	public Product factory() {%0a%3c 		return new ConcreteProductB();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteProductA.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public class ConcreteProductA implements Product {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteProductB.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public class ConcreteProductB implements Product {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Creator.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public interface Creator {%0a%3c 	public Product factory();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Product.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public interface Product {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.FactoryMethod;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Creator creatorA = new ConcreteCreatorA();%0a%3c 		Creator creatorB = new ConcreteCreatorB();%0a%3c 		Product product = creatorA.factory();%0a%3c 		System.out.println(product);%0a%3c 		product = creatorB.factory();%0a%3c 		System.out.println(product);%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319029166=117.89.207.43
