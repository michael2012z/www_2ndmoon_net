version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319033783
host=117.89.207.43
name=DesignPattern.TemplateMethod
rev=2
targets=DesignPattern.TemplateMethod
text=\\%0a %0a[+++''模版方法模式/Template Method''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a模版方法模式其实是一种应用很广泛的模式，特别是在使用抽象类的时候。%0a%0a模版方法模式中必然有一个核心的抽象类，不能是接口。声明一些抽象方法，这些方法由子类来做各不相同的实现；也可以是一些非抽象的方法，这些方法只是做为默认的实现，子类应该覆盖它们。%0a%0a此外，还要定义一个或多少具体的方法，它们实现一些逻辑，调用前面提到的抽象或非抽象方法。这种方法就本模式中最重要的部分，这样的方法一般规定了调用其它抽象方法的逻辑，所以它是一个模版，这个方法就称为模版方法。%0a%0a模版方法一般不被子类覆盖，否则就失去了“模版”的作用。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/TemplateMethod/TemplateMethod.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/TemplateMethod/TemplateMethod.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象模版(Abstract Template)：%0a** 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作。%0a** 定义并实现一个模版方法，这是一个具体的方法，给出了一个逻辑骨架，以固定的顺序和条件来调用其它的抽象方法。它定义了调用逻辑，是一个模版。%0a# 具体模版(Concrete Template)：%0a** 以自己的方式实现父类所定义的抽象方法。%0a%0a[+++''要点：''+++]%0a%0a模版方法模式中的方法：%0a# 模版方法：%0a** 一个模版方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个方法在抽象类中定义，并由子类不加修改地完全继承。%0a# 基本方法：%0a主要由子类来实现或重写，体现继承关系的方法称为基本方法。基本方法又可以分为三种：%0a** 抽象方法：必须由子类来实现的方法。%0a** 具体方法：具体方法仍然由抽象类实现，而子类并不实现或重写。有些具体方法可以起来工厂方法的作用。%0a** 钩子方法：钩子方法也由抽象类来实现，但这只是作为一种默认的实现，一般是空的。子类应该重新实现，如果没有的话，只是说明不需要。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  AbstractTemplate.java %0a%0apackage designPatterns.TemplateMethod;%0a%0apublic abstract class AbstractTemplate {%0a	// abstract method%0a	protected abstract void abstractMethod();%0a	%0a	// hook method, provide default implementation%0a	protected void hookMethod() {%0a		System.out.println("AbstractTemplate.hookMethod()");%0a	}%0a	%0a	// template method%0a	public void templateMethod() {%0a		abstractMethod();%0a		hookMethod();%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteClassA.java %0a%0apackage designPatterns.TemplateMethod;%0a%0apublic class ConcreteClassA extends AbstractTemplate {%0a%0a	protected void abstractMethod() {%0a		System.out.println("ConcreteClassA.abstractMethod()");%0a	}%0a	%0a	protected void hookMethod() {%0a		System.out.println("ConcreteClassA.hookMethod()");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ConcreteClassB.java %0a%0apackage designPatterns.TemplateMethod;%0a%0apublic class ConcreteClassB extends AbstractTemplate {%0a%0a	protected void abstractMethod() {%0a		System.out.println("ConcreteClassB.abstractMethod()");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.TemplateMethod;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		AbstractTemplate a = new ConcreteClassA();%0a		AbstractTemplate b = new ConcreteClassB();%0a		a.templateMethod();%0a		b.templateMethod();%0a	}%0a}%0a(:sourcend:)
time=1319036850
author:1319036850=
diff:1319036850:1319033783:=16,17c16%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/TemplateMethod/TemplateMethod.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/TemplateMethod/TemplateMethod.png]]%0a%3c %0a---%0a>  %0a
host:1319036850=117.89.207.43
author:1319033783=
diff:1319033783:1319033783:=1,100d0%0a%3c \\%0a%3c  %0a%3c [+++''模版方法模式/Template Method''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 模版方法模式其实是一种应用很广泛的模式，特别是在使用抽象类的时候。%0a%3c %0a%3c 模版方法模式中必然有一个核心的抽象类，不能是接口。声明一些抽象方法，这些方法由子类来做各不相同的实现；也可以是一些非抽象的方法，这些方法只是做为默认的实现，子类应该覆盖它们。%0a%3c %0a%3c 此外，还要定义一个或多少具体的方法，它们实现一些逻辑，调用前面提到的抽象或非抽象方法。这种方法就本模式中最重要的部分，这样的方法一般规定了调用其它抽象方法的逻辑，所以它是一个模版，这个方法就称为模版方法。%0a%3c %0a%3c 模版方法一般不被子类覆盖，否则就失去了“模版”的作用。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象模版(Abstract Template)：%0a%3c ** 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作。%0a%3c ** 定义并实现一个模版方法，这是一个具体的方法，给出了一个逻辑骨架，以固定的顺序和条件来调用其它的抽象方法。它定义了调用逻辑，是一个模版。%0a%3c # 具体模版(Concrete Template)：%0a%3c ** 以自己的方式实现父类所定义的抽象方法。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 模版方法模式中的方法：%0a%3c # 模版方法：%0a%3c ** 一个模版方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个方法在抽象类中定义，并由子类不加修改地完全继承。%0a%3c # 基本方法：%0a%3c 主要由子类来实现或重写，体现继承关系的方法称为基本方法。基本方法又可以分为三种：%0a%3c ** 抽象方法：必须由子类来实现的方法。%0a%3c ** 具体方法：具体方法仍然由抽象类实现，而子类并不实现或重写。有些具体方法可以起来工厂方法的作用。%0a%3c ** 钩子方法：钩子方法也由抽象类来实现，但这只是作为一种默认的实现，一般是空的。子类应该重新实现，如果没有的话，只是说明不需要。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  AbstractTemplate.java %0a%3c %0a%3c package designPatterns.TemplateMethod;%0a%3c %0a%3c public abstract class AbstractTemplate {%0a%3c 	// abstract method%0a%3c 	protected abstract void abstractMethod();%0a%3c 	%0a%3c 	// hook method, provide default implementation%0a%3c 	protected void hookMethod() {%0a%3c 		System.out.println("AbstractTemplate.hookMethod()");%0a%3c 	}%0a%3c 	%0a%3c 	// template method%0a%3c 	public void templateMethod() {%0a%3c 		abstractMethod();%0a%3c 		hookMethod();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteClassA.java %0a%3c %0a%3c package designPatterns.TemplateMethod;%0a%3c %0a%3c public class ConcreteClassA extends AbstractTemplate {%0a%3c %0a%3c 	protected void abstractMethod() {%0a%3c 		System.out.println("ConcreteClassA.abstractMethod()");%0a%3c 	}%0a%3c 	%0a%3c 	protected void hookMethod() {%0a%3c 		System.out.println("ConcreteClassA.hookMethod()");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteClassB.java %0a%3c %0a%3c package designPatterns.TemplateMethod;%0a%3c %0a%3c public class ConcreteClassB extends AbstractTemplate {%0a%3c %0a%3c 	protected void abstractMethod() {%0a%3c 		System.out.println("ConcreteClassB.abstractMethod()");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.TemplateMethod;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		AbstractTemplate a = new ConcreteClassA();%0a%3c 		AbstractTemplate b = new ConcreteClassB();%0a%3c 		a.templateMethod();%0a%3c 		b.templateMethod();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319033783=117.89.207.43
