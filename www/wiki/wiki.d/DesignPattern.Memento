version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319035373
host=117.89.207.43
name=DesignPattern.Memento
rev=3
targets=DesignPattern.Memento
text=\\%0a %0a[+++'''备忘录模式/Memento'''+++]%0a%0a[+++''意图/适用场景：''+++]\\%0a备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。\\%0a备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉住，并存储起来。在将来合适的时候把这个对象还原到存储时的状态。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Memento/Memento.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Memento/Memento.png]]%0a%0a[+++''参与者：''+++]%0a# 发起人(Originator)：需要保存自身状态的对象。它有两个功能，一是创建新的备忘录，一是恢复到已有的备忘录。%0a# 管理者(Caretaker)：负责管理备忘录，最主要的功能有两个：一是把备忘录存储起来，一是从存储设备中读取备忘录。%0a# 备忘录接口(Memento)：备忘录的公共接口，不提供任何方法。%0a# 备忘录宽接口(MementoWideIF)：这一接口是给Originator使用的，主要面向状态管理的功能，提供读写状态的方法。%0a# 备忘录窄接口(MementoNarrowIF)：这一接口是给Caretaker使用的，主要面向存储功能，提供序列化的方法。%0a# 具体备忘录(ConcreteMemento)：同时实现宽窄两个接口，同时提供状态读写和序列化的功能。%0a%0a%0a[+++''要点：''+++]\\%0a本模式里一个关键的地方在于ConcreteMemento角色同时实现了MementoWideIF和MementoNarrowIF两个接口。之所以这样设计是出于接口隔离的考虑。Originator即状态的使用者不关心备忘录如果被存储；而管理者也不应该看到与状态有关的细节，它只关心备忘录的存储。所以最好让它们分别面向不同的接口，互相不知道另一方以及另一套接口的存在。%0a%0a[+++''应用实例：''+++]\\%0a电视游戏中的save/load功能是一个很好的例子。当玩家保存游戏进度时，就相当于建立了一份备忘录并把它存储起来，当然玩家可以建立不只一份的备忘录。\\%0a当再次游戏时，可以从已保存的多个进度中选择一个，继续游戏，这时就相当于把游戏场景恢复到保存时的状态。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Caretaker.java %0a%0apackage designPatterns.Memento;%0a%0apublic class Caretaker {%0a	%0a	public void saveMemento(Memento m) {%0a		MementoNarrowIF mn = (MementoNarrowIF)m;%0a		mn.serialize();%0a	}%0a	%0a	public Memento loadMemento() {%0a		// This is just for demo.%0a		// Caretaker don't know ConcreteMemento. It just get a Memento from other place.%0a		return new ConcreteMemento();%0a	}%0a	%0a}%0a%0a%0a// Source code from file:  ConcreteMemento.java %0a%0apackage designPatterns.Memento;%0a%0apublic class ConcreteMemento implements MementoWideIF, MementoNarrowIF {%0a%0a	private int state = 0;%0a	%0a	public int getState() {%0a		return state;%0a	}%0a%0a	public void setState(int state) {%0a		this.state = state;%0a	}%0a%0a	public void serialize() {%0a		System.out.println("Memento was serialized.");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  Memento.java %0a%0apackage designPatterns.Memento;%0a%0apublic interface Memento {%0a%0a}%0a%0a%0a// Source code from file:  MementoNarrowIF.java %0a%0apackage designPatterns.Memento;%0a%0apublic interface MementoNarrowIF extends Memento {%0a	public void serialize();%0a}%0a%0a%0a// Source code from file:  MementoWideIF.java %0a%0apackage designPatterns.Memento;%0a%0apublic interface MementoWideIF extends Memento {%0a	public void setState(int state);%0a	public int getState();%0a}%0a%0a%0a// Source code from file:  Originator.java %0a%0apackage designPatterns.Memento;%0a%0apublic class Originator {%0a%0a	private int state = 0;%0a	%0a	public Memento createMemento() {%0a		ConcreteMemento m = new ConcreteMemento();%0a		m.setState(state);%0a		System.out.println("create memento with state " + state);%0a		return m;%0a	}%0a	%0a	public void restoreMemento(Memento m) {%0a		MementoWideIF mw = (ConcreteMemento)m;%0a		state = mw.getState();%0a		System.out.println("restore memento with state " + state);%0a	}%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Memento;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Originator o = new Originator();%0a		Caretaker c = new Caretaker();%0a		// save memento%0a		Memento m = o.createMemento();%0a		c.saveMemento(m);%0a		// load memento%0a		m = c.loadMemento();%0a		o.restoreMemento(m);%0a	}%0a}%0a(:sourcend:)
time=1319037014
author:1319037014=
diff:1319037014:1319035401:=10,11c10%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Memento/Memento.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Memento/Memento.png]]%0a%3c %0a---%0a>  %0a
host:1319037014=117.89.207.43
author:1319035401=
diff:1319035401:1319035373:=18d17%0a%3c %0a
host:1319035401=117.89.207.43
author:1319035373=
diff:1319035373:1319035373:=1,138d0%0a%3c \\%0a%3c  %0a%3c [+++'''备忘录模式/Memento'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]\\%0a%3c 备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。\\%0a%3c 备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捕捉住，并存储起来。在将来合适的时候把这个对象还原到存储时的状态。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 发起人(Originator)：需要保存自身状态的对象。它有两个功能，一是创建新的备忘录，一是恢复到已有的备忘录。%0a%3c # 管理者(Caretaker)：负责管理备忘录，最主要的功能有两个：一是把备忘录存储起来，一是从存储设备中读取备忘录。%0a%3c # 备忘录接口(Memento)：备忘录的公共接口，不提供任何方法。%0a%3c # 备忘录宽接口(MementoWideIF)：这一接口是给Originator使用的，主要面向状态管理的功能，提供读写状态的方法。%0a%3c # 备忘录窄接口(MementoNarrowIF)：这一接口是给Caretaker使用的，主要面向存储功能，提供序列化的方法。%0a%3c # 具体备忘录(ConcreteMemento)：同时实现宽窄两个接口，同时提供状态读写和序列化的功能。%0a%3c %0a%3c [+++''要点：''+++]\\%0a%3c 本模式里一个关键的地方在于ConcreteMemento角色同时实现了MementoWideIF和MementoNarrowIF两个接口。之所以这样设计是出于接口隔离的考虑。Originator即状态的使用者不关心备忘录如果被存储；而管理者也不应该看到与状态有关的细节，它只关心备忘录的存储。所以最好让它们分别面向不同的接口，互相不知道另一方以及另一套接口的存在。%0a%3c %0a%3c [+++''应用实例：''+++]\\%0a%3c 电视游戏中的save/load功能是一个很好的例子。当玩家保存游戏进度时，就相当于建立了一份备忘录并把它存储起来，当然玩家可以建立不只一份的备忘录。\\%0a%3c 当再次游戏时，可以从已保存的多个进度中选择一个，继续游戏，这时就相当于把游戏场景恢复到保存时的状态。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Caretaker.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public class Caretaker {%0a%3c 	%0a%3c 	public void saveMemento(Memento m) {%0a%3c 		MementoNarrowIF mn = (MementoNarrowIF)m;%0a%3c 		mn.serialize();%0a%3c 	}%0a%3c 	%0a%3c 	public Memento loadMemento() {%0a%3c 		// This is just for demo.%0a%3c 		// Caretaker don't know ConcreteMemento. It just get a Memento from other place.%0a%3c 		return new ConcreteMemento();%0a%3c 	}%0a%3c 	%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteMemento.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public class ConcreteMemento implements MementoWideIF, MementoNarrowIF {%0a%3c %0a%3c 	private int state = 0;%0a%3c 	%0a%3c 	public int getState() {%0a%3c 		return state;%0a%3c 	}%0a%3c %0a%3c 	public void setState(int state) {%0a%3c 		this.state = state;%0a%3c 	}%0a%3c %0a%3c 	public void serialize() {%0a%3c 		System.out.println("Memento was serialized.");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Memento.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public interface Memento {%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  MementoNarrowIF.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public interface MementoNarrowIF extends Memento {%0a%3c 	public void serialize();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  MementoWideIF.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public interface MementoWideIF extends Memento {%0a%3c 	public void setState(int state);%0a%3c 	public int getState();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Originator.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public class Originator {%0a%3c %0a%3c 	private int state = 0;%0a%3c 	%0a%3c 	public Memento createMemento() {%0a%3c 		ConcreteMemento m = new ConcreteMemento();%0a%3c 		m.setState(state);%0a%3c 		System.out.println("create memento with state " + state);%0a%3c 		return m;%0a%3c 	}%0a%3c 	%0a%3c 	public void restoreMemento(Memento m) {%0a%3c 		MementoWideIF mw = (ConcreteMemento)m;%0a%3c 		state = mw.getState();%0a%3c 		System.out.println("restore memento with state " + state);%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Memento;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Originator o = new Originator();%0a%3c 		Caretaker c = new Caretaker();%0a%3c 		// save memento%0a%3c 		Memento m = o.createMemento();%0a%3c 		c.saveMemento(m);%0a%3c 		// load memento%0a%3c 		m = c.loadMemento();%0a%3c 		o.restoreMemento(m);%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319035373=117.89.207.43
