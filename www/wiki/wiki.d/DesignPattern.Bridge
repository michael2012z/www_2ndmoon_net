version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319033276
host=180.109.20.194
name=DesignPattern.Bridge
rev=5
targets=DesignPattern.Bridge
text=\\%0a %0a[+++'''桥梁模式/Bridge'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a桥梁模式的意图在于把“抽象”与“实现”解耦合，把强关联转变为弱关联。%0a%0a所谓强关联，就是在编译时期已经确定的，无法在运行时期改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。%0a%0a将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改为弱关联。因此，桥梁模式中的所谓解耦合，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系，从而使两者都可以相对独立地变化。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png]]%0a%0a[+++''参与者：''+++]%0a# 抽象化角色(Abstraction)：抽象化给出的定义，并保存一个对实现化对象的引用。%0a# 修正抽象化角色(RefinedAbstraction)：扩展抽象化角色，改变和修正父类对抽象化的定义。%0a# 实现化角色(Implementor)：实现类的接口，定义实现类的方法。这些方法与抽象化角色所提供的方法不需要相同，甚至可以完全不同。%0a# 具体实现化角色(ConcreteImplementor)：实现化角色的具体实现类。%0a%0a[+++''要点：''+++]%0a%0a桥梁模式的系统中有两个等级结构：%0a# 由抽象化角色和修正抽象化角色组成的抽象化等级结构。%0a# 由实现化角色和具体实现化角色所组成的实现化等级结构。%0a抽象化等级结构是提供给用户或者系统其它部分使用的，是稳定不易变的；而实现化等级结构是可以替换的，比如在不同的环境中，使用不同的实现化，这也正是解耦合的目标。%0a%0a%0a[+++''应用实例：''+++]%0a%0aAWT的Peer架构\\%0aJava语言具有跨平台的功能。相同的代码使用AWT库绘制的界面，在不同的操作系统上功能相同，但外观风格不同。这里就应用了桥梁模式，把Java的AWT调用与操作系统native调用有效地解耦合。%0a在AWT库中的每一个Component的子类都有一个ComponentPeer的子类与之匹配。所有的Component的子类都属于一个等级结构，即抽象化等级结构；而所有的ComponentPeer的子类都属于另一个等级结构，即实现化等级结构。Component类型和ComponentPeer类型通过Toolkit对象相互通信。%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png]]%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Abstraction.java %0a%0apackage designPatterns.Bridge;%0a%0apublic class Abstraction {%0a	protected Implementor imp;%0a	%0a	public void operation() {%0a		imp.operationImp();%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteImplementorA.java %0a%0apackage designPatterns.Bridge;%0a%0apublic class ConcreteImplementorA implements Implementor {%0a	public void operationImp() {%0a		System.out.println("ConcreteImplementorA.operationImp()");%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteImplementorB.java %0a%0apackage designPatterns.Bridge;%0a%0apublic class ConcreteImplementorB implements Implementor {%0a	public void operationImp() {%0a		System.out.println("ConcreteImplementorB.operationImp()");%0a	}%0a}%0a%0a%0a// Source code from file:  Implementor.java %0a%0apackage designPatterns.Bridge;%0a%0apublic interface Implementor {%0a	public void operationImp();%0a}%0a%0a%0a// Source code from file:  RefinedAbstraction.java %0a%0apackage designPatterns.Bridge;%0a%0apublic class RefinedAbstraction extends Abstraction {%0a	%0a	public RefinedAbstraction(String systemType) {%0a		if (systemType.equals("SystemA"))%0a			imp = new ConcreteImplementorA();%0a		else if (systemType.equals("SystemB"))%0a			imp = new ConcreteImplementorB();%0a	}%0a	%0a	public void operation() {%0a		// do some thing%0a		super.operation();%0a	}%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Bridge;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Abstraction absA = new RefinedAbstraction("SystemA");%0a		absA.operation();%0a		Abstraction absB = new RefinedAbstraction("SystemB");%0a		absB.operation();%0a	}%0a}%0a(:sourcend:)
time=1319381024
author:1319381024=
diff:1319381024:1319380998:=35c35%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png]]%0a---%0a> %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png]]%0a
host:1319381024=180.109.20.194
author:1319380998=
diff:1319380998:1319036782:=35d34%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/diagram1.png]]%0a
host:1319380998=180.109.20.194
author:1319036782=
diff:1319036782:1319036631:=
host:1319036782=117.89.207.43
author:1319036631=
diff:1319036631:1319033276:=14,15c14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Bridge/Bridge.png]]%0a%3c %0a---%0a>  %0a
host:1319036631=117.89.207.43
author:1319033276=
diff:1319033276:1319033276:=1,113d0%0a%3c \\%0a%3c  %0a%3c [+++'''桥梁模式/Bridge'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 桥梁模式的意图在于把“抽象”与“实现”解耦合，把强关联转变为弱关联。%0a%3c %0a%3c 所谓强关联，就是在编译时期已经确定的，无法在运行时期改变的关联；所谓弱关联，就是可以动态地确定并且可以在运行时期动态地改变的关联。显然，在Java语言中，继承关系是强关联，而聚合关系是弱关联。%0a%3c %0a%3c 将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改为弱关联。因此，桥梁模式中的所谓解耦合，就是指在一个软件系统的抽象化和实现化之间使用聚合关系而不是继承关系，从而使两者都可以相对独立地变化。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 抽象化角色(Abstraction)：抽象化给出的定义，并保存一个对实现化对象的引用。%0a%3c # 修正抽象化角色(RefinedAbstraction)：扩展抽象化角色，改变和修正父类对抽象化的定义。%0a%3c # 实现化角色(Implementor)：实现类的接口，定义实现类的方法。这些方法与抽象化角色所提供的方法不需要相同，甚至可以完全不同。%0a%3c # 具体实现化角色(ConcreteImplementor)：实现化角色的具体实现类。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 桥梁模式的系统中有两个等级结构：%0a%3c # 由抽象化角色和修正抽象化角色组成的抽象化等级结构。%0a%3c # 由实现化角色和具体实现化角色所组成的实现化等级结构。%0a%3c 抽象化等级结构是提供给用户或者系统其它部分使用的，是稳定不易变的；而实现化等级结构是可以替换的，比如在不同的环境中，使用不同的实现化，这也正是解耦合的目标。%0a%3c %0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c %0a%3c AWT的Peer架构\\%0a%3c Java语言具有跨平台的功能。相同的代码使用AWT库绘制的界面，在不同的操作系统上功能相同，但外观风格不同。这里就应用了桥梁模式，把Java的AWT调用与操作系统native调用有效地解耦合。%0a%3c 在AWT库中的每一个Component的子类都有一个ComponentPeer的子类与之匹配。所有的Component的子类都属于一个等级结构，即抽象化等级结构；而所有的ComponentPeer的子类都属于另一个等级结构，即实现化等级结构。Component类型和ComponentPeer类型通过Toolkit对象相互通信。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Abstraction.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public class Abstraction {%0a%3c 	protected Implementor imp;%0a%3c 	%0a%3c 	public void operation() {%0a%3c 		imp.operationImp();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteImplementorA.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public class ConcreteImplementorA implements Implementor {%0a%3c 	public void operationImp() {%0a%3c 		System.out.println("ConcreteImplementorA.operationImp()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteImplementorB.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public class ConcreteImplementorB implements Implementor {%0a%3c 	public void operationImp() {%0a%3c 		System.out.println("ConcreteImplementorB.operationImp()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Implementor.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public interface Implementor {%0a%3c 	public void operationImp();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  RefinedAbstraction.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public class RefinedAbstraction extends Abstraction {%0a%3c 	%0a%3c 	public RefinedAbstraction(String systemType) {%0a%3c 		if (systemType.equals("SystemA"))%0a%3c 			imp = new ConcreteImplementorA();%0a%3c 		else if (systemType.equals("SystemB"))%0a%3c 			imp = new ConcreteImplementorB();%0a%3c 	}%0a%3c 	%0a%3c 	public void operation() {%0a%3c 		// do some thing%0a%3c 		super.operation();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Bridge;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Abstraction absA = new RefinedAbstraction("SystemA");%0a%3c 		absA.operation();%0a%3c 		Abstraction absB = new RefinedAbstraction("SystemB");%0a%3c 		absB.operation();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319033276=117.89.207.43
