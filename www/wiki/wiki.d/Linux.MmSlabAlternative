version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.41 Safari/534.7
author=
charset=UTF-8
csum=
ctime=1289102282
host=112.21.41.85
name=Linux.MmSlabAlternative
rev=1
targets=
text=!! Alternative Allocators%0a%0a%0aAlthough the slab allocator works well for many possible workloads, there are naturally situations in which it fails to provide optimal performance. Problems arise when slab allocation is used on machines that range on the borders of the current hardware scale: tiny embedded systems and large, massively parallel systems equipped with huge amounts of RAM. In the second case, the large amount of metadata required by the slab allocator can become a problem: developers have reported that many gigabytes of memory are required only for the slab data structures on large systems. For embedded systems, the total footprint and complexity of slab allocation can simply be too much.%0a%0aTo cope with such situations, two drop-in replacements for the slab allocator were added during the development of kernel 2.6:%0a%0a❑ The slob allocator is especially optimized for low code size. It is centered around a simple linked lists of blocks (thus its name). To allocate memory, a likewise simple first-fit algorithm is used.\\%0aWith only roughly 600 lines, the total footprint of the slob allocator is very small. Naturally, it is not the most efficient allocator in terms of speed and is definitely not designed to be used on large-scale systems. %0a%0a❑ The slub allocator tries to minimize the required memory overhead by packing page frames into groups and to manage these groups by overloading unused fields in struct page. While this certainly does not simplify the definition of this structure, as you have seen before, the effort is justified by the better performance of slub in contrast to slab on large machines.%0a
time=1289102282
author:1289102282=
diff:1289102282:1289102282:=1,11d0%0a%3c !! Alternative Allocators%0a%3c %0a%3c %0a%3c Although the slab allocator works well for many possible workloads, there are naturally situations in which it fails to provide optimal performance. Problems arise when slab allocation is used on machines that range on the borders of the current hardware scale: tiny embedded systems and large, massively parallel systems equipped with huge amounts of RAM. In the second case, the large amount of metadata required by the slab allocator can become a problem: developers have reported that many gigabytes of memory are required only for the slab data structures on large systems. For embedded systems, the total footprint and complexity of slab allocation can simply be too much.%0a%3c %0a%3c To cope with such situations, two drop-in replacements for the slab allocator were added during the development of kernel 2.6:%0a%3c %0a%3c ❑ The slob allocator is especially optimized for low code size. It is centered around a simple linked lists of blocks (thus its name). To allocate memory, a likewise simple first-fit algorithm is used.\\%0a%3c With only roughly 600 lines, the total footprint of the slob allocator is very small. Naturally, it is not the most efficient allocator in terms of speed and is definitely not designed to be used on large-scale systems. %0a%3c %0a%3c ❑ The slub allocator tries to minimize the required memory overhead by packing page frames into groups and to manage these groups by overloading unused fields in struct page. While this certainly does not simplify the definition of this structure, as you have seen before, the effort is justified by the better performance of slub in contrast to slab on large machines.%0a
host:1289102282=112.21.41.85
