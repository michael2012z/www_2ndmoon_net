version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.41 Safari/534.7
author=
charset=UTF-8
csum=
ctime=1288321422
host=114.80.140.34
name=Linux.PTEFlags
rev=1
targets=
text=!! Common properties of a PTE%0a%0a❑ _PAGE_PRESENT specifies whether the virtual page is present in RAM memory. This need not necessarily be the case because pages may be swapped out into a swap area as noted briefly in Chapter 1.\\%0aThe structure of the page table entry is usually different if the page is not present in memory because there is no need to describe the position of the page in memory. Instead, information is needed to identify and find the swapped-out page.\\%0a❑ _PAGE_ACCESSED is set automatically by the CPU each time the page is accessed. The kernel regularly checks the field to establish how actively the page is used (infrequently used pages are good swapping candidates). The bit is set after either read or write access.\\%0a❑ _PAGE_DIRTY indicates whether the page is ‘‘dirty,’’ that is, whether the page contents have been modified.\\%0a❑ _PAGE_FILE has the same numerical value as _PAGE_DIRTY, but is used in a different context, namely, when a page is not present in memory. Obviously, a page that is not present cannot be dirty, so the bit can be reinterpreted: If it is not set, then the entry points to the location of a swapped-out page (see Chapter 18). A set _PAGE_FILE is required for entries that belongs to nonlinear file mappings which are discussed in Section 4.7.3.\\%0a❑ If _PAGE_USER is set, userspace code is allowed to access the page. Otherwise, only the kernel is allowed to do this (or when the CPU is in system mode).\\%0a❑ _PAGE_READ, _PAGE_WRITE, and _PAGE_EXECUTE specify whether normal user processes are allowed to read the page, write to the page, or execute the machine code in the page. Pages from kernel memory must be protected against writing by user processes. There is, however, no assurance that even pages belonging to user processes can be written to, for example, if the page contains executable code that may not be modified — either intentionally%0aor unintentionally. Architectures that feature less finely grained access rights define the _PAGE_RW constant to allow or disallow read and write access in combination if no further criterion is available to distinguish%0abetween the two.\\%0a❑ IA-32 andAMD64 provide _PAGE_BIT_NX to label the contents of a page as not executable (this protection bit is only available on IA-32 systems if the page address extensions for addressing 64 GiB memory are enabled). It can prevent, for example, execution of code on stack pages that can result in security gaps in programs because of intentionally provoked buffer overflows if malicious code has been introduced. The NX bit cannot prevent buffer overflow but can suppress its effects because the process refuses to run the malicious code. Of course, the same result can also be achieved if the architectures themselves provide a good set of access authorization bits for memory pages, as is the case with some (unfortunately not very common)%0aprocessors.
time=1288321422
author:1288321422=
diff:1288321422:1288321422:=1,13d0%0a%3c !! Common properties of a PTE%0a%3c %0a%3c ❑ _PAGE_PRESENT specifies whether the virtual page is present in RAM memory. This need not necessarily be the case because pages may be swapped out into a swap area as noted briefly in Chapter 1.\\%0a%3c The structure of the page table entry is usually different if the page is not present in memory because there is no need to describe the position of the page in memory. Instead, information is needed to identify and find the swapped-out page.\\%0a%3c ❑ _PAGE_ACCESSED is set automatically by the CPU each time the page is accessed. The kernel regularly checks the field to establish how actively the page is used (infrequently used pages are good swapping candidates). The bit is set after either read or write access.\\%0a%3c ❑ _PAGE_DIRTY indicates whether the page is ‘‘dirty,’’ that is, whether the page contents have been modified.\\%0a%3c ❑ _PAGE_FILE has the same numerical value as _PAGE_DIRTY, but is used in a different context, namely, when a page is not present in memory. Obviously, a page that is not present cannot be dirty, so the bit can be reinterpreted: If it is not set, then the entry points to the location of a swapped-out page (see Chapter 18). A set _PAGE_FILE is required for entries that belongs to nonlinear file mappings which are discussed in Section 4.7.3.\\%0a%3c ❑ If _PAGE_USER is set, userspace code is allowed to access the page. Otherwise, only the kernel is allowed to do this (or when the CPU is in system mode).\\%0a%3c ❑ _PAGE_READ, _PAGE_WRITE, and _PAGE_EXECUTE specify whether normal user processes are allowed to read the page, write to the page, or execute the machine code in the page. Pages from kernel memory must be protected against writing by user processes. There is, however, no assurance that even pages belonging to user processes can be written to, for example, if the page contains executable code that may not be modified — either intentionally%0a%3c or unintentionally. Architectures that feature less finely grained access rights define the _PAGE_RW constant to allow or disallow read and write access in combination if no further criterion is available to distinguish%0a%3c between the two.\\%0a%3c ❑ IA-32 andAMD64 provide _PAGE_BIT_NX to label the contents of a page as not executable (this protection bit is only available on IA-32 systems if the page address extensions for addressing 64 GiB memory are enabled). It can prevent, for example, execution of code on stack pages that can result in security gaps in programs because of intentionally provoked buffer overflows if malicious code has been introduced. The NX bit cannot prevent buffer overflow but can suppress its effects because the process refuses to run the malicious code. Of course, the same result can also be achieved if the architectures themselves provide a good set of access authorization bits for memory pages, as is the case with some (unfortunately not very common)%0a%3c processors.%0a\ No newline at end of file%0a
host:1288321422=114.80.140.34
