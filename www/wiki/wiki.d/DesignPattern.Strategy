version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319033638
host=180.109.20.194
name=DesignPattern.Strategy
rev=3
targets=DesignPattern.Strategy
text=\\%0a%0a[+++'''策略模式/Strategy'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a策略模式是针对一组算法，将每一个算法封装到具有共同接口的独立类中，从而使得它们可以互换。这样做的好处是，客户端可以以插件的方式更换算法。%0a%0a电子商务网站的购物车系统是一个策略模式非常适用的场景：比如，在优惠方式上，某一类商品是每件优惠一元，另一类商品是折扣5%25，还有一类商品也是打折，但折扣幅度是10%25。所以需要应用不同的优惠算法来计算最终的价格。%0a%0a在这个系统中，可以想象到会有一个计算者角色（与本模式中的Context相同功能），它负责计算价格。但如果把所有的算法都放在它里面来实现的话，会比较混乱。如果应用策略模式的话，就可以把行为和上下文环境分开。上下文类（计算者）中负责维持和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，算法的增减、修改都不会影响到上下文和客户端。这也为上下文类减轻了负担。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/Strategy.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/Strategy.png]]%0a%0a[+++''参与者：''+++]%0a# 上下文角色(Context)：持有一个Strategy类的引用。%0a# 抽象策略角色(Strategy)：抽象角色，通常是一个接口或者抽象类。定义出所有的具体策略类的公共接口。如果具体策略类有共同的行为，可以把Strategy定义为抽象类，并实现这些公共的行为；否则最好定义为接口。%0a# 具体策略(ConcreteStrategy)：包装了相关的算法或行为。%0a%0a[+++''要点：''+++]%0a%0a在下面的情况下应当考虑使用策略模式：%0a# 系统需要动态地在多种算法中选择一种；%0a# 算法很多，如果由一个角色来处理的话，逻辑会非常混乱；%0a# 算法不可让客户端知道。%0a%0a策略模式的最大优点在于把算法分门别类，由不同的实体类来维护，实现了算法本身与算法的使用者之间的弱耦合。而且把一个搅在一起的大算法分而治之，避免了大量使用条件而造成的混乱。%0a%0a[+++''应用实例：''+++]%0a%0a排序策略系统，参见《Java与模式》本章。%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/diagram1.png]]%0a%0a[+++''相关模式：''+++]%0a%0a以下模式在结构上与策略模式相似，它们的区别多半在于用意不同，适用的场景是不同的。%0a# 策略模式：强调的是算法的分治与选择。%0a# 建造模式：它的核心功能是以一步一步的方式创建一个产品，把各个零件分别制造并组装起来，最后形成一个产品。%0a# 适配模式：它的用意在于把不同接口的对象“转接”成客户端所需要的接口。%0a# 装饰模式：它的用意在于在不改变接口的情况下，增强一个对象的功能。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  ConcreteStrategyA.java %0a%0apackage designPatterns.Strategy;%0a%0apublic class ConcreteStrategyA implements Strategy {%0a	public void strategy() {%0a		System.out.println("ConcreteStrategyA.strategy()");%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteStrategyB.java %0a%0apackage designPatterns.Strategy;%0a%0apublic class ConcreteStrategyB implements Strategy {%0a	public void strategy() {%0a		System.out.println("ConcreteStrategyA.strategy()");%0a	}%0a}%0a%0a%0a// Source code from file:  Context.java %0a%0apackage designPatterns.Strategy;%0a%0apublic class Context {%0a	private Strategy strategy;%0a	%0a	public void strategy(char type) {%0a		if ('A' == type)%0a			strategy = new ConcreteStrategyA();%0a		else if ('B' == type)%0a			strategy = new ConcreteStrategyB();%0a		strategy.strategy();%0a	}%0a}%0a%0a%0a// Source code from file:  Strategy.java %0a%0apackage designPatterns.Strategy;%0a%0apublic interface Strategy {%0a	public void strategy();%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Strategy;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Context ctxt = new Context();%0a		ctxt.strategy('A');%0a		ctxt.strategy('B');%0a	}%0a}%0a(:sourcend:)
time=1319381256
author:1319381256=
diff:1319381256:1319036820:=33c33%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/diagram1.png]]%0a---%0a>  %0a
host:1319381256=180.109.20.194
author:1319036820=
diff:1319036820:1319033638:=14,15c14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/Strategy.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Strategy/Strategy.png]]%0a%3c %0a---%0a>  %0a
host:1319036820=117.89.207.43
author:1319033638=
diff:1319033638:1319033638:=1,103d0%0a%3c \\%0a%3c %0a%3c [+++'''策略模式/Strategy'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 策略模式是针对一组算法，将每一个算法封装到具有共同接口的独立类中，从而使得它们可以互换。这样做的好处是，客户端可以以插件的方式更换算法。%0a%3c %0a%3c 电子商务网站的购物车系统是一个策略模式非常适用的场景：比如，在优惠方式上，某一类商品是每件优惠一元，另一类商品是折扣5%25，还有一类商品也是打折，但折扣幅度是10%25。所以需要应用不同的优惠算法来计算最终的价格。%0a%3c %0a%3c 在这个系统中，可以想象到会有一个计算者角色（与本模式中的Context相同功能），它负责计算价格。但如果把所有的算法都放在它里面来实现的话，会比较混乱。如果应用策略模式的话，就可以把行为和上下文环境分开。上下文类（计算者）中负责维持和查询行为类，各种算法则在具体策略类中提供。由于算法和环境独立开来，算法的增减、修改都不会影响到上下文和客户端。这也为上下文类减轻了负担。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # 上下文角色(Context)：持有一个Strategy类的引用。%0a%3c # 抽象策略角色(Strategy)：抽象角色，通常是一个接口或者抽象类。定义出所有的具体策略类的公共接口。如果具体策略类有共同的行为，可以把Strategy定义为抽象类，并实现这些公共的行为；否则最好定义为接口。%0a%3c # 具体策略(ConcreteStrategy)：包装了相关的算法或行为。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 在下面的情况下应当考虑使用策略模式：%0a%3c # 系统需要动态地在多种算法中选择一种；%0a%3c # 算法很多，如果由一个角色来处理的话，逻辑会非常混乱；%0a%3c # 算法不可让客户端知道。%0a%3c %0a%3c 策略模式的最大优点在于把算法分门别类，由不同的实体类来维护，实现了算法本身与算法的使用者之间的弱耦合。而且把一个搅在一起的大算法分而治之，避免了大量使用条件而造成的混乱。%0a%3c %0a%3c [+++''应用实例：''+++]%0a%3c %0a%3c 排序策略系统，参见《Java与模式》本章。%0a%3c  %0a%3c %0a%3c [+++''相关模式：''+++]%0a%3c %0a%3c 以下模式在结构上与策略模式相似，它们的区别多半在于用意不同，适用的场景是不同的。%0a%3c # 策略模式：强调的是算法的分治与选择。%0a%3c # 建造模式：它的核心功能是以一步一步的方式创建一个产品，把各个零件分别制造并组装起来，最后形成一个产品。%0a%3c # 适配模式：它的用意在于把不同接口的对象“转接”成客户端所需要的接口。%0a%3c # 装饰模式：它的用意在于在不改变接口的情况下，增强一个对象的功能。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  ConcreteStrategyA.java %0a%3c %0a%3c package designPatterns.Strategy;%0a%3c %0a%3c public class ConcreteStrategyA implements Strategy {%0a%3c 	public void strategy() {%0a%3c 		System.out.println("ConcreteStrategyA.strategy()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteStrategyB.java %0a%3c %0a%3c package designPatterns.Strategy;%0a%3c %0a%3c public class ConcreteStrategyB implements Strategy {%0a%3c 	public void strategy() {%0a%3c 		System.out.println("ConcreteStrategyA.strategy()");%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Context.java %0a%3c %0a%3c package designPatterns.Strategy;%0a%3c %0a%3c public class Context {%0a%3c 	private Strategy strategy;%0a%3c 	%0a%3c 	public void strategy(char type) {%0a%3c 		if ('A' == type)%0a%3c 			strategy = new ConcreteStrategyA();%0a%3c 		else if ('B' == type)%0a%3c 			strategy = new ConcreteStrategyB();%0a%3c 		strategy.strategy();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Strategy.java %0a%3c %0a%3c package designPatterns.Strategy;%0a%3c %0a%3c public interface Strategy {%0a%3c 	public void strategy();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Strategy;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Context ctxt = new Context();%0a%3c 		ctxt.strategy('A');%0a%3c 		ctxt.strategy('B');%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319033638=117.89.207.43
