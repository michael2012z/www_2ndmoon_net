version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12
author=
charset=UTF-8
csum=
ctime=1290592626
host=194.237.142.10
name=Linux.LockSemaphores
rev=1
targets=
text=In contrast to spinlocks, semaphores are suitable for protecting longer critical sections against parallel access. However, they should not be used to protect shorter sections because it is very costly to put processes to sleep and wake them up again — as happens when the semaphore is contended.%0a%0aIn most cases, the full potential of semaphores is not required, but they are used in the form of mutexes, which are nothing other than binary semaphores. To simplify this case, the kernel provides the macros DECLARE_MUTEX, which declare a binary semaphore that starts out unlocked with count = 1.%0a%0aWhen an attempt is made to acquire a reserved semaphore with down, the current process is put to sleep and placed on the wait queue associated with the semaphore. At the same time, the process is placed in the TASK_UNINTERRUPTIBLE state and cannot receive signals while waiting to enter the critical region. If the semaphore is not reserved, the process may immediately continue without being put to sleep and enters the critical region, but not without reserving the semaphore first.%0a%0aup() must be called when the critical region is exited. The routine is responsible for waking one of the processes sleeping on the semaphore — this process is then allowed to enter the critical section, and all%0aother processes continue to sleep. %0a%0aIn addition to down(), two other operations are used to reserve a semaphore (unlike spinlocks, only one up() function is available and is used to exit the section protected by a semaphore):%0a%0a# down_interruptible() works in the same way as down but places the task in the TASK_INTERRUPTIBLE state if the semaphore could not be acquired. As a result, the process can be woken by signals while it is sleeping.%0a%0a# down_trylock attempts to acquire a semaphore. If it fails, the process does not go to sleep to wait for the semaphore but continues execution normally. If the semaphore is acquired, the function returns a false value, otherwise a true value.
time=1290592626
author:1290592626=
diff:1290592626:1290592626:=1,14d0%0a%3c In contrast to spinlocks, semaphores are suitable for protecting longer critical sections against parallel access. However, they should not be used to protect shorter sections because it is very costly to put processes to sleep and wake them up again — as happens when the semaphore is contended.%0a%3c %0a%3c In most cases, the full potential of semaphores is not required, but they are used in the form of mutexes, which are nothing other than binary semaphores. To simplify this case, the kernel provides the macros DECLARE_MUTEX, which declare a binary semaphore that starts out unlocked with count = 1.%0a%3c %0a%3c When an attempt is made to acquire a reserved semaphore with down, the current process is put to sleep and placed on the wait queue associated with the semaphore. At the same time, the process is placed in the TASK_UNINTERRUPTIBLE state and cannot receive signals while waiting to enter the critical region. If the semaphore is not reserved, the process may immediately continue without being put to sleep and enters the critical region, but not without reserving the semaphore first.%0a%3c %0a%3c up() must be called when the critical region is exited. The routine is responsible for waking one of the processes sleeping on the semaphore — this process is then allowed to enter the critical section, and all%0a%3c other processes continue to sleep. %0a%3c %0a%3c In addition to down(), two other operations are used to reserve a semaphore (unlike spinlocks, only one up() function is available and is used to exit the section protected by a semaphore):%0a%3c %0a%3c # down_interruptible() works in the same way as down but places the task in the TASK_INTERRUPTIBLE state if the semaphore could not be acquired. As a result, the process can be woken by signals while it is sleeping.%0a%3c %0a%3c # down_trylock attempts to acquire a semaphore. If it fails, the process does not go to sleep to wait for the semaphore but continues execution normally. If the semaphore is acquired, the function returns a false value, otherwise a true value.%0a\ No newline at end of file%0a
host:1290592626=194.237.142.10
