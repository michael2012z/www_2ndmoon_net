version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US) AppleWebKit/534.7 (KHTML, like Gecko) Chrome/7.0.517.41 Safari/534.7
author=
charset=UTF-8
csum=
ctime=1288316782
host=114.80.140.34
name=Linux.PageFlags
rev=2
targets=
text=!! Architecture-Independent Page Flags%0a%0aThe different attributes of a page are described by a series of page flags stored as bits in the flags element of struct page. The flags are independent of the architecture used and cannot therefore provide CPU- or machine-specific information (this information is held in the page table itself as is shown below).%0a%0aNot only are the individual flags defined with the help of the pre-processor in page-flags.h, but also macros are generated to set, delete, and query the flags. In doing so, the kernel conforms to a universal naming scheme; for example, the PG_locked constant defines the bit position in flags to specify whether a page is locked or not. The following macros are available to manipulate the bit:%0a%0a❑ PageLocked queries whether the bit is set.\\%0a❑ SetPageLocked sets the PG_locked bit, regardless of its previous state.\\%0a❑ TestSetPageLocked sets the bit, but also returns its old value.\\%0a❑ ClearPageLocked deletes the bit regardless of its previous state.\\%0a❑ TestClearPageLocked deletes the bit and returns its old value.%0a%0aThere is an identical set of macros to perform the operations shown on the appropriate bit for the other page flags. The macros are implemented atomically. Although some of them are made up of several statements, special processor commands are used to ensure that they act as if they were a single statement; that is, they cannot be interrupted as this would result in race conditions. (Chapter 14 describes how race conditions arise and how they can be prevented.)%0a%0a---- %0a%0aWhich page flags are available? The following list includes the most important flags (again, their meanings become clear in later chapters):%0a%0a❑ PG_locked specifies whether a page is locked. If the bit is set, other parts of the kernel are not allowed to access the page. This prevents race conditions in memory management, for example, when reading data from hard disk into a page frame.\\%0a❑ PG_error is set if an error occurs during an I/O operation involving the page.\\%0a❑ PG_referenced and PG_active control how actively a page is used by the system. This information is important when the swapping subsystem has to select which page to swap out. The interaction of the two flags is explained in Chapter 18.\\%0a❑ PG_uptodate indicates that the data of a page have been read without error from a block device.\\%0a❑ PG_dirty is set when the contents of the page have changed as compared to the data on hard disk. For reasons of performance, pages are not written back immediately after each change. The kernel therefore uses this flag to note which pages have been changed so that they can be flushed later.\\%0aPages for which this flag has been set are referred to as dirty (generally, this means that the data in RAM and the data on a secondary storage medium such as a hard disk have not been synchronized).\\%0a❑ PG_lru helps implement page reclaim and swapping. The kernel uses two least recently used lists8 to distinguish between active and inactive pages. The bit is set if the page is held on one of these lists. There is also a PG_active flag that is set if the page is on the list of active pages.%0aChapter 18 discusses this important mechanism in detail.\\%0a❑ PG_highmem indicates that a page is in high memory because it cannot be mapped permanently into kernel memory.\\%0a❑ PG_private must be set if the value of the private element in the page structure is non-NULL.\\%0aPages that are used for I/O use this field to subdivide the page into buffers (see Chapter 16 for more information), but other parts of the kernel find different uses to attach private data to a page.\\%0a❑ PG_writeback is set for pages whose contents are in the process of being written back to a block device.\\%0a❑ PG_slab is set for pages that are part of the slab allocator discussed in Section 3.6.\\%0a❑ PG_swapcache is set if the page is in the swap cache; in this case, private contains an entry of type swap_entry_t (further details are provided in Chapter 18).%0a❑ When the available amount of memory gets smaller, the kernel tries to periodically reclaim pages, that is, get rid of inactive, unused pages. Chapter 18 discusses the details. Once the kernel has decided to reclaim a specific page, this is announced by setting the PG_reclaim flag.\\%0a❑ PG_buddy is set if the page is free and contained on the lists of the buddy system, that is, the core of the page allocation mechanism.\\%0a❑ PG_compound denotes that the page is part of a larger compound page consisting of multiple adjacent regular pages.%0a%0a---- %0a%0aA number of standard macros are defined to check if a page has a specific bit is set, or to manipulate a bit. Their names follow a certain pattern:%0a%0a❑ PageXXX(page) checks if a page has the PG_XXX bit set. For instance, PageDirty checks for the PG_dirty bit, while PageActive checks for PG_active, and so on.\\%0a❑ To set a bit if it is not set and return the previous value, SetPageXXX is provided.\\%0a❑ ClearPageXXX unconditionally deletes a specific bit.\\%0a❑ TestClearPageXXX clears a bit if it is set, but also returns the previously active value. Notice that these operations are implemented atomically. %0a
time=1288316893
author:1288316893=
diff:1288316893:1288316782:=44a45,56%0a> %0a> ----%0a> %0a> Often it is necessary to wait until the state of a page changes, and then resume work. Two auxiliary functions provided by the kernel are of particular interest for us:%0a> ->%3cpagemap.h>%0a> void wait_on_page_locked(struct page *page);%0a> void wait_on_page_writeback(struct page *page)%0a> -%3cAssume that one part of the kernel wants to wait until a locked page has been unlocked. wait_on_page_locked allows for doing this. While how this is technically done is discussed in Chapter 14, it suffices to know here that after calling the function, the kernel will go to sleep if the page%0a> is locked. Once the page becomes unlocked, the sleeper is automatically woken up and can continue its work.%0a> %0a> wait_on_page_writeback works similarly, but waits until any pending writeback operations in which the data contained in the page are synchronized with a block device — a hard disk, for instance — have%0a> been finished.%0a\ No newline at end of file%0a
host:1288316893=114.80.140.34
author:1288316782=
diff:1288316782:1288316782:=1,56d0%0a%3c !! Architecture-Independent Page Flags%0a%3c %0a%3c The different attributes of a page are described by a series of page flags stored as bits in the flags element of struct page. The flags are independent of the architecture used and cannot therefore provide CPU- or machine-specific information (this information is held in the page table itself as is shown below).%0a%3c %0a%3c Not only are the individual flags defined with the help of the pre-processor in page-flags.h, but also macros are generated to set, delete, and query the flags. In doing so, the kernel conforms to a universal naming scheme; for example, the PG_locked constant defines the bit position in flags to specify whether a page is locked or not. The following macros are available to manipulate the bit:%0a%3c %0a%3c ❑ PageLocked queries whether the bit is set.\\%0a%3c ❑ SetPageLocked sets the PG_locked bit, regardless of its previous state.\\%0a%3c ❑ TestSetPageLocked sets the bit, but also returns its old value.\\%0a%3c ❑ ClearPageLocked deletes the bit regardless of its previous state.\\%0a%3c ❑ TestClearPageLocked deletes the bit and returns its old value.%0a%3c %0a%3c There is an identical set of macros to perform the operations shown on the appropriate bit for the other page flags. The macros are implemented atomically. Although some of them are made up of several statements, special processor commands are used to ensure that they act as if they were a single statement; that is, they cannot be interrupted as this would result in race conditions. (Chapter 14 describes how race conditions arise and how they can be prevented.)%0a%3c %0a%3c ---- %0a%3c %0a%3c Which page flags are available? The following list includes the most important flags (again, their meanings become clear in later chapters):%0a%3c %0a%3c ❑ PG_locked specifies whether a page is locked. If the bit is set, other parts of the kernel are not allowed to access the page. This prevents race conditions in memory management, for example, when reading data from hard disk into a page frame.\\%0a%3c ❑ PG_error is set if an error occurs during an I/O operation involving the page.\\%0a%3c ❑ PG_referenced and PG_active control how actively a page is used by the system. This information is important when the swapping subsystem has to select which page to swap out. The interaction of the two flags is explained in Chapter 18.\\%0a%3c ❑ PG_uptodate indicates that the data of a page have been read without error from a block device.\\%0a%3c ❑ PG_dirty is set when the contents of the page have changed as compared to the data on hard disk. For reasons of performance, pages are not written back immediately after each change. The kernel therefore uses this flag to note which pages have been changed so that they can be flushed later.\\%0a%3c Pages for which this flag has been set are referred to as dirty (generally, this means that the data in RAM and the data on a secondary storage medium such as a hard disk have not been synchronized).\\%0a%3c ❑ PG_lru helps implement page reclaim and swapping. The kernel uses two least recently used lists8 to distinguish between active and inactive pages. The bit is set if the page is held on one of these lists. There is also a PG_active flag that is set if the page is on the list of active pages.%0a%3c Chapter 18 discusses this important mechanism in detail.\\%0a%3c ❑ PG_highmem indicates that a page is in high memory because it cannot be mapped permanently into kernel memory.\\%0a%3c ❑ PG_private must be set if the value of the private element in the page structure is non-NULL.\\%0a%3c Pages that are used for I/O use this field to subdivide the page into buffers (see Chapter 16 for more information), but other parts of the kernel find different uses to attach private data to a page.\\%0a%3c ❑ PG_writeback is set for pages whose contents are in the process of being written back to a block device.\\%0a%3c ❑ PG_slab is set for pages that are part of the slab allocator discussed in Section 3.6.\\%0a%3c ❑ PG_swapcache is set if the page is in the swap cache; in this case, private contains an entry of type swap_entry_t (further details are provided in Chapter 18).%0a%3c ❑ When the available amount of memory gets smaller, the kernel tries to periodically reclaim pages, that is, get rid of inactive, unused pages. Chapter 18 discusses the details. Once the kernel has decided to reclaim a specific page, this is announced by setting the PG_reclaim flag.\\%0a%3c ❑ PG_buddy is set if the page is free and contained on the lists of the buddy system, that is, the core of the page allocation mechanism.\\%0a%3c ❑ PG_compound denotes that the page is part of a larger compound page consisting of multiple adjacent regular pages.%0a%3c %0a%3c ---- %0a%3c %0a%3c A number of standard macros are defined to check if a page has a specific bit is set, or to manipulate a bit. Their names follow a certain pattern:%0a%3c %0a%3c ❑ PageXXX(page) checks if a page has the PG_XXX bit set. For instance, PageDirty checks for the PG_dirty bit, while PageActive checks for PG_active, and so on.\\%0a%3c ❑ To set a bit if it is not set and return the previous value, SetPageXXX is provided.\\%0a%3c ❑ ClearPageXXX unconditionally deletes a specific bit.\\%0a%3c ❑ TestClearPageXXX clears a bit if it is set, but also returns the previously active value. Notice that these operations are implemented atomically. %0a%3c %0a%3c ----%0a%3c %0a%3c Often it is necessary to wait until the state of a page changes, and then resume work. Two auxiliary functions provided by the kernel are of particular interest for us:%0a%3c ->%3cpagemap.h>%0a%3c void wait_on_page_locked(struct page *page);%0a%3c void wait_on_page_writeback(struct page *page)%0a%3c -%3cAssume that one part of the kernel wants to wait until a locked page has been unlocked. wait_on_page_locked allows for doing this. While how this is technically done is discussed in Chapter 14, it suffices to know here that after calling the function, the kernel will go to sleep if the page%0a%3c is locked. Once the page becomes unlocked, the sleeper is automatically woken up and can continue its work.%0a%3c %0a%3c wait_on_page_writeback works similarly, but waits until any pending writeback operations in which the data contained in the page are synchronized with a block device — a hard disk, for instance — have%0a%3c been finished.%0a\ No newline at end of file%0a
host:1288316782=114.80.140.34
