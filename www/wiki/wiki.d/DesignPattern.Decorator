version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319032025
host=117.89.207.43
name=DesignPattern.Decorator
rev=3
targets=DesignPattern.Decorator
text=\\%0a%0a[+++'''装饰模式/Decorator'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a装饰模式将更多的功能动态地附加到一个对象上。对功能扩展而言，装饰模式提供了一个灵活的、可以替代“继承”的选择。%0a%0a装饰模式通过被装饰类的一个子类的实例，把客户端的调用委派到被装饰类。%0a%0a在以下情况下应当使用装饰模式：%0a# 需要扩展一个类的功能，或给一个类增加责任。%0a# 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。%0a# 需要增加同一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Decorator/Decorator.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Decorator/Decorator.png]]%0a%0a[+++''参与者：''+++]%0a# Component: 一个抽象接口，规范了准备接收附加功能/责任的对象。%0a# Concrete Component: 定义一个将要接收附加功能/责任的类。%0a# Decorator: 持有一个Component对象的实例，并且实现Component接口。在实现的接口方法中，调用Component对象的相应方法来实现功能。%0a# Concrete Decorator: 负责给Component对象附加功能。%0a%0a[+++''要点：''+++]%0a%0aDecorator模式的设计思想在于，系统中会有很多个Concrete Decorator，而每一个Concrete Decorator可以把其它的Concrete Decorator作为自己的基础，在其之上增加一些功能。%0a%0a而这些功能扩展是动态的，而且是多变的，各种Concrete Decorator可以随意地互相组合。这不同于基于继承的扩展，后者是静态的、不变的。%0a%0a优点与缺点:%0a# 装饰模式与继承关系的目的都是扩展对象的功能，但装饰模式可以提供更多的灵活性。%0a# 通过使用不同的Concrete Decorator以及它们的组合，可以创造出很多不同行为的组合。%0a# 使用装饰模式比使用继承关系需要的类数目更少，但对象的数目会更多，而且对象间的组合关系会更加复杂。%0a%0a[+++''扩展：''+++]%0a%0a看下面的这幅对象关系图。这是Decorator模式的典型用法，对象的数量还可以更多，层数也可以更多。在每一层，Concrete Decorator对下一层的功能做一点扩展，最后实现了庞大的功能集合。%0a也可以这样理解，Concrete Component被一层一层的Concrete Decorator所包裹，所以这种模式也常常被称为“包裹”模式。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Component.java %0a%0apackage designPatterns.Decorator;%0a%0apublic interface Component {%0a	public void sampleOperation();%0a}%0a%0a%0a// Source code from file:  ConcreteComponent.java %0a%0apackage designPatterns.Decorator;%0a%0apublic class ConcreteComponent implements Component {%0a%0a	public void sampleOperation() {%0a		System.out.println("ConcreteComponent.sampleOperation()");%0a	}%0a%0a}%0a%0a%0a// Source code from file:  ConcreteDecoratorA.java %0a%0apackage designPatterns.Decorator;%0a%0apublic class ConcreteDecoratorA extends Decorator {%0a	%0a	private Decorator decorator;%0a	%0a	public ConcreteDecoratorA() {%0a		this.decorator = null;%0a	}%0a	%0a	public ConcreteDecoratorA(Decorator decorator) {%0a		this.decorator = decorator;%0a	}%0a	%0a	public void sampleOperation() {%0a		System.out.println("ConcreteDecoratorA.sampleOperation()");%0a		if (null != decorator)%0a			decorator.sampleOperation();%0a	}%0a}%0a%0a%0a// Source code from file:  ConcreteDecoratorB.java %0a%0apackage designPatterns.Decorator;%0a%0apublic class ConcreteDecoratorB extends Decorator {%0a	%0a	private Decorator decorator;%0a	%0a	public ConcreteDecoratorB() {%0a		this.decorator = null;%0a	}%0a	%0a	public ConcreteDecoratorB(Decorator decorator) {%0a		this.decorator = decorator;%0a	}%0a	%0a	public void sampleOperation() {%0a		System.out.println("ConcreteDecoratorB.sampleOperation()");%0a		if (null != decorator)%0a			decorator.sampleOperation();%0a	}%0a}%0a%0a%0a// Source code from file:  Decorator.java %0a%0apackage designPatterns.Decorator;%0a%0apublic class Decorator implements Component {%0a%0a	private Component component;%0a	%0a	public Decorator() {%0a		// make a default component;%0a		component = new ConcreteComponent();%0a	}%0a	%0a	public Decorator(Component component) {%0a		this.component = component;%0a	}%0a	%0a	public void sampleOperation() {%0a		System.out.println("Decorator.sampleOperation()");%0a		component.sampleOperation();%0a	}%0a%0a}%0a%0a%0a// Source code from file:  User.java %0a%0apackage designPatterns.Decorator;%0a%0apublic class User {%0a	public static void main(String[] args) {%0a		Component c = new ConcreteComponent();%0a		Decorator decorator = new Decorator(c);%0a		Decorator a = new ConcreteDecoratorA(decorator);%0a		Decorator b = new ConcreteDecoratorB(a);%0a		b.sampleOperation();%0a		%0a		System.out.println();%0a		%0a		// re-org%0a		b = new ConcreteDecoratorB(decorator);%0a		a = new ConcreteDecoratorA(b);%0a		a.sampleOperation();%0a	}%0a}%0a(:sourcend:)
time=1319036450
author:1319036450=
diff:1319036450:1319032045:=17,18c17%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Decorator/Decorator.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Decorator/Decorator.png]]%0a%3c %0a---%0a>  %0a
host:1319036450=117.89.207.43
author:1319032045=
diff:1319032045:1319032025:=25d24%0a%3c %0a
host:1319032045=117.89.207.43
author:1319032025=
diff:1319032025:1319032025:=1,156d0%0a%3c \\%0a%3c %0a%3c [+++'''装饰模式/Decorator'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 装饰模式将更多的功能动态地附加到一个对象上。对功能扩展而言，装饰模式提供了一个灵活的、可以替代“继承”的选择。%0a%3c %0a%3c 装饰模式通过被装饰类的一个子类的实例，把客户端的调用委派到被装饰类。%0a%3c %0a%3c 在以下情况下应当使用装饰模式：%0a%3c # 需要扩展一个类的功能，或给一个类增加责任。%0a%3c # 需要动态地给一个对象增加功能，这些功能可以再动态地撤销。%0a%3c # 需要增加同一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # Component: 一个抽象接口，规范了准备接收附加功能/责任的对象。%0a%3c # Concrete Component: 定义一个将要接收附加功能/责任的类。%0a%3c # Decorator: 持有一个Component对象的实例，并且实现Component接口。在实现的接口方法中，调用Component对象的相应方法来实现功能。%0a%3c # Concrete Decorator: 负责给Component对象附加功能。%0a%3c %0a%3c [+++''要点：''+++]%0a%3c Decorator模式的设计思想在于，系统中会有很多个Concrete Decorator，而每一个Concrete Decorator可以把其它的Concrete Decorator作为自己的基础，在其之上增加一些功能。%0a%3c %0a%3c 而这些功能扩展是动态的，而且是多变的，各种Concrete Decorator可以随意地互相组合。这不同于基于继承的扩展，后者是静态的、不变的。%0a%3c %0a%3c 优点与缺点:%0a%3c # 装饰模式与继承关系的目的都是扩展对象的功能，但装饰模式可以提供更多的灵活性。%0a%3c # 通过使用不同的Concrete Decorator以及它们的组合，可以创造出很多不同行为的组合。%0a%3c # 使用装饰模式比使用继承关系需要的类数目更少，但对象的数目会更多，而且对象间的组合关系会更加复杂。%0a%3c %0a%3c [+++''扩展：''+++]%0a%3c %0a%3c 看下面的这幅对象关系图。这是Decorator模式的典型用法，对象的数量还可以更多，层数也可以更多。在每一层，Concrete Decorator对下一层的功能做一点扩展，最后实现了庞大的功能集合。%0a%3c 也可以这样理解，Concrete Component被一层一层的Concrete Decorator所包裹，所以这种模式也常常被称为“包裹”模式。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Component.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public interface Component {%0a%3c 	public void sampleOperation();%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteComponent.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public class ConcreteComponent implements Component {%0a%3c %0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("ConcreteComponent.sampleOperation()");%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteDecoratorA.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public class ConcreteDecoratorA extends Decorator {%0a%3c 	%0a%3c 	private Decorator decorator;%0a%3c 	%0a%3c 	public ConcreteDecoratorA() {%0a%3c 		this.decorator = null;%0a%3c 	}%0a%3c 	%0a%3c 	public ConcreteDecoratorA(Decorator decorator) {%0a%3c 		this.decorator = decorator;%0a%3c 	}%0a%3c 	%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("ConcreteDecoratorA.sampleOperation()");%0a%3c 		if (null != decorator)%0a%3c 			decorator.sampleOperation();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  ConcreteDecoratorB.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public class ConcreteDecoratorB extends Decorator {%0a%3c 	%0a%3c 	private Decorator decorator;%0a%3c 	%0a%3c 	public ConcreteDecoratorB() {%0a%3c 		this.decorator = null;%0a%3c 	}%0a%3c 	%0a%3c 	public ConcreteDecoratorB(Decorator decorator) {%0a%3c 		this.decorator = decorator;%0a%3c 	}%0a%3c 	%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("ConcreteDecoratorB.sampleOperation()");%0a%3c 		if (null != decorator)%0a%3c 			decorator.sampleOperation();%0a%3c 	}%0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  Decorator.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public class Decorator implements Component {%0a%3c %0a%3c 	private Component component;%0a%3c 	%0a%3c 	public Decorator() {%0a%3c 		// make a default component;%0a%3c 		component = new ConcreteComponent();%0a%3c 	}%0a%3c 	%0a%3c 	public Decorator(Component component) {%0a%3c 		this.component = component;%0a%3c 	}%0a%3c 	%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("Decorator.sampleOperation()");%0a%3c 		component.sampleOperation();%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c // Source code from file:  User.java %0a%3c %0a%3c package designPatterns.Decorator;%0a%3c %0a%3c public class User {%0a%3c 	public static void main(String[] args) {%0a%3c 		Component c = new ConcreteComponent();%0a%3c 		Decorator decorator = new Decorator(c);%0a%3c 		Decorator a = new ConcreteDecoratorA(decorator);%0a%3c 		Decorator b = new ConcreteDecoratorB(a);%0a%3c 		b.sampleOperation();%0a%3c 		%0a%3c 		System.out.println();%0a%3c 		%0a%3c 		// re-org%0a%3c 		b = new ConcreteDecoratorB(decorator);%0a%3c 		a = new ConcreteDecoratorA(b);%0a%3c 		a.sampleOperation();%0a%3c 	}%0a%3c }%0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1319032025=117.89.207.43
