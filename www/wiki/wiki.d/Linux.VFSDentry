version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2
author=
charset=UTF-8
csum=
ctime=1322490984
host=180.109.20.119
name=Linux.VFSDentry
rev=2
targets=Linux.VFSDentry
text=!! Dentry%0a%0aThe dentries encode the filesystem tree structure, the names of the files. Thus, the main parts of a dentry are the inode (if any) that belongs to it, the name (the final part of the pathname), and the parent (the name of the containing directory). There are also the superblocks, the methods, a list of subdirectories, etc.%0a%0a(:source lang=c:)%0astruct dentry {%0a	/* RCU lookup touched fields */%0a	unsigned int d_flags;		/* protected by d_lock */%0a	seqcount_t d_seq;		/* per dentry seqlock */%0a	struct hlist_bl_node d_hash;	/* lookup hash list */%0a	struct dentry *d_parent;	/* parent directory */%0a	struct qstr d_name;%0a	struct inode *d_inode;		/* Where the name belongs to - NULL is%0a					 * negative */%0a	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */%0a%0a	/* Ref lookup also touches following */%0a	unsigned int d_count;		/* protected by d_lock */%0a	spinlock_t d_lock;		/* per dentry lock */%0a	const struct dentry_operations *d_op;%0a	struct super_block *d_sb;	/* The root of the dentry tree */%0a	unsigned long d_time;		/* used by d_revalidate */%0a	void *d_fsdata;			/* fs-specific data */%0a%0a	struct list_head d_lru;		/* LRU list */%0a	/*%0a	 * d_child and d_rcu can share memory%0a	 */%0a	union {%0a		struct list_head d_child;	/* child of parent list */%0a	 	struct rcu_head d_rcu;%0a	} d_u;%0a	struct list_head d_subdirs;	/* our children */%0a	struct list_head d_alias;	/* inode alias list */%0a};%0a(:sourcend:)%0a%0a(:source lang=c:)%0astruct dentry_operations {%0a	int (*d_revalidate)(struct dentry *, struct nameidata *);%0a	int (*d_hash)(const struct dentry *, const struct inode *,%0a			struct qstr *);%0a	int (*d_compare)(const struct dentry *, const struct inode *,%0a			const struct dentry *, const struct inode *,%0a			unsigned int, const char *, const struct qstr *);%0a	int (*d_delete)(const struct dentry *);%0a	void (*d_release)(struct dentry *);%0a	void (*d_prune)(struct dentry *);%0a	void (*d_iput)(struct dentry *, struct inode *);%0a	char *(*d_dname)(struct dentry *, char *, int);%0a	struct vfsmount *(*d_automount)(struct path *);%0a	int (*d_manage)(struct dentry *, bool);%0a} ____cacheline_aligned;%0a(:sourcend:)%0a%0a!!! Value of a dentry%0a%0aThe pathname represented by a dentry, is the concatenation of the name of its parent d_parent, a slash character, and its own name d_name.%0a%0aHowever, if the dentry is the root of a mounted filesystem (i.e., if dentry->d_covers != dentry), then its pathname is the pathname of the mount point d_covers. Finally, the pathname of the root of the filesystem (with dentry->d_parent == dentry) is "/", and this is also its d_name.%0a%0aThe d_mounts and d_covers fields of a dentry point back to the dentry itself, except that the d_covers field of the dentry for the root of a mounted filesystem points back to the dentry for the mount point, while the d_mounts field of the dentry for the mount point points at the dentry for the root of a mounted filesystem.%0a%0aThe d_parent field of a dentry points back to the dentry for the directory in which it lives. It points back to the dentry itself in case of the root of a filesystem.%0a%0aA dentry is called negative if it does not have an associated inode, i.e., if it is a name only.%0a%0aWe see that although a dentry represents a pathname, there may be several dentries for the same pathname, namely when overmounting has taken place. Such dentries have different inodes.%0a%0aOf course the converse, an inode with several dentries, can also occur.%0a%0aThe above description, with d_mounts and d_covers, was for 2.4. In 2.5 these fields have disappeared, and we only have the integer d_mounted that indicates how many filesystems have been mounted at that point. In case it is nonzero (this is what d_mountpoint() tests), a hash table lookup can find the actual mounted filesystem.%0a%0a%0aEach dentry is on five lists, with links through the fields d_hash, d_lru, d_child, d_subdirs, d_alias.%0a%0a!!! d_hash%0a%0aDentries are used to speed up the lookup operation. A hash table dentry_hashtable is used, with an index that is a hash of the name and the parent. The hash collision chain has links through the dentry fields d_hash. This chain is protected by the spinlock dcache_lock.%0a%0a!!! d_lru%0a%0aAll unused dentries are collected in a list dentry_unused with links in the dentry fields d_lru. This list is protected by the spinlock dcache_lock.%0a%0a!!! d_child, d_subdirs%0a%0aAll subdirectories of a given directory are collected in a list headed by the dentry field d_subdirs with links in the dentry fields d_child. These lists are protected by the spinlock dcache_lock.%0a%0a!!! d_alias%0a%0aAll dentries belonging to the same inode are collected in a list headed by the inode field i_dentry with links in the dentry fields d_alias. This list is protected by the spinlock dcache_lock.%0a
time=1322569684
author:1322569684=
diff:1322569684:1322490984:=1,4d0%0a%3c !! Dentry%0a%3c %0a%3c The dentries encode the filesystem tree structure, the names of the files. Thus, the main parts of a dentry are the inode (if any) that belongs to it, the name (the final part of the pathname), and the parent (the name of the containing directory). There are also the superblocks, the methods, a list of subdirectories, etc.%0a%3c %0a5a2%0a> %0a36,91c33,34%0a%3c (:sourcend:)%0a%3c %0a%3c (:source lang=c:)%0a%3c struct dentry_operations {%0a%3c 	int (*d_revalidate)(struct dentry *, struct nameidata *);%0a%3c 	int (*d_hash)(const struct dentry *, const struct inode *,%0a%3c 			struct qstr *);%0a%3c 	int (*d_compare)(const struct dentry *, const struct inode *,%0a%3c 			const struct dentry *, const struct inode *,%0a%3c 			unsigned int, const char *, const struct qstr *);%0a%3c 	int (*d_delete)(const struct dentry *);%0a%3c 	void (*d_release)(struct dentry *);%0a%3c 	void (*d_prune)(struct dentry *);%0a%3c 	void (*d_iput)(struct dentry *, struct inode *);%0a%3c 	char *(*d_dname)(struct dentry *, char *, int);%0a%3c 	struct vfsmount *(*d_automount)(struct path *);%0a%3c 	int (*d_manage)(struct dentry *, bool);%0a%3c } ____cacheline_aligned;%0a%3c (:sourcend:)%0a%3c %0a%3c !!! Value of a dentry%0a%3c %0a%3c The pathname represented by a dentry, is the concatenation of the name of its parent d_parent, a slash character, and its own name d_name.%0a%3c %0a%3c However, if the dentry is the root of a mounted filesystem (i.e., if dentry->d_covers != dentry), then its pathname is the pathname of the mount point d_covers. Finally, the pathname of the root of the filesystem (with dentry->d_parent == dentry) is "/", and this is also its d_name.%0a%3c %0a%3c The d_mounts and d_covers fields of a dentry point back to the dentry itself, except that the d_covers field of the dentry for the root of a mounted filesystem points back to the dentry for the mount point, while the d_mounts field of the dentry for the mount point points at the dentry for the root of a mounted filesystem.%0a%3c %0a%3c The d_parent field of a dentry points back to the dentry for the directory in which it lives. It points back to the dentry itself in case of the root of a filesystem.%0a%3c %0a%3c A dentry is called negative if it does not have an associated inode, i.e., if it is a name only.%0a%3c %0a%3c We see that although a dentry represents a pathname, there may be several dentries for the same pathname, namely when overmounting has taken place. Such dentries have different inodes.%0a%3c %0a%3c Of course the converse, an inode with several dentries, can also occur.%0a%3c %0a%3c The above description, with d_mounts and d_covers, was for 2.4. In 2.5 these fields have disappeared, and we only have the integer d_mounted that indicates how many filesystems have been mounted at that point. In case it is nonzero (this is what d_mountpoint() tests), a hash table lookup can find the actual mounted filesystem.%0a%3c %0a%3c %0a%3c Each dentry is on five lists, with links through the fields d_hash, d_lru, d_child, d_subdirs, d_alias.%0a%3c %0a%3c !!! d_hash%0a%3c %0a%3c Dentries are used to speed up the lookup operation. A hash table dentry_hashtable is used, with an index that is a hash of the name and the parent. The hash collision chain has links through the dentry fields d_hash. This chain is protected by the spinlock dcache_lock.%0a%3c %0a%3c !!! d_lru%0a%3c %0a%3c All unused dentries are collected in a list dentry_unused with links in the dentry fields d_lru. This list is protected by the spinlock dcache_lock.%0a%3c %0a%3c !!! d_child, d_subdirs%0a%3c %0a%3c All subdirectories of a given directory are collected in a list headed by the dentry field d_subdirs with links in the dentry fields d_child. These lists are protected by the spinlock dcache_lock.%0a%3c %0a%3c !!! d_alias%0a%3c %0a%3c All dentries belonging to the same inode are collected in a list headed by the inode field i_dentry with links in the dentry fields d_alias. This list is protected by the spinlock dcache_lock.%0a---%0a> %0a> (:sourcend:)%0a\ No newline at end of file%0a
host:1322569684=180.109.20.119
author:1322490984=
diff:1322490984:1322490984:=1,34d0%0a%3c (:source lang=c:)%0a%3c %0a%3c struct dentry {%0a%3c 	/* RCU lookup touched fields */%0a%3c 	unsigned int d_flags;		/* protected by d_lock */%0a%3c 	seqcount_t d_seq;		/* per dentry seqlock */%0a%3c 	struct hlist_bl_node d_hash;	/* lookup hash list */%0a%3c 	struct dentry *d_parent;	/* parent directory */%0a%3c 	struct qstr d_name;%0a%3c 	struct inode *d_inode;		/* Where the name belongs to - NULL is%0a%3c 					 * negative */%0a%3c 	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */%0a%3c %0a%3c 	/* Ref lookup also touches following */%0a%3c 	unsigned int d_count;		/* protected by d_lock */%0a%3c 	spinlock_t d_lock;		/* per dentry lock */%0a%3c 	const struct dentry_operations *d_op;%0a%3c 	struct super_block *d_sb;	/* The root of the dentry tree */%0a%3c 	unsigned long d_time;		/* used by d_revalidate */%0a%3c 	void *d_fsdata;			/* fs-specific data */%0a%3c %0a%3c 	struct list_head d_lru;		/* LRU list */%0a%3c 	/*%0a%3c 	 * d_child and d_rcu can share memory%0a%3c 	 */%0a%3c 	union {%0a%3c 		struct list_head d_child;	/* child of parent list */%0a%3c 	 	struct rcu_head d_rcu;%0a%3c 	} d_u;%0a%3c 	struct list_head d_subdirs;	/* our children */%0a%3c 	struct list_head d_alias;	/* inode alias list */%0a%3c };%0a%3c %0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1322490984=58.212.192.21
