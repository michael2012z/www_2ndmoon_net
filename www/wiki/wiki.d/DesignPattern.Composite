version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.202 Safari/535.1
author=
charset=UTF-8
csum=
ctime=1319031835
host=180.109.20.194
name=DesignPattern.Composite
rev=4
targets=DesignPattern.Composite
text=\\%0a%0a[+++'''合成模式/Composite'''+++]%0a%0a[+++''意图/适用场景：''+++]%0a%0a合成模式又叫做部分-整体模式。它将对象组织到树结构中，可以用来描述整体与部分的关系。最显著的特点就是把整体与部分都抽象出统一的接口，这样客户端就可以把单纯元素与复合元素同等看待。%0a%0a看下图所示的树状结构图。图中有两种节点，一种是树枝节点，一种是树叶节点。树根也是一种树枝节点，只不过它比较特殊，它没有父节点。%0a%0a在构建这样的一种树状结构里，合成模式提供了三种元素：%0a# Component: 它是所有“节点”的抽象接口，无论是树枝还是树叶，首先都是Component。%0a# Leaf: 它是“树叶”的实现类，实现Component接口。%0a# Composite: 它是“树枝”的实现类，实现Component接口。它也是合成模式的关键元素，因为它可以使得整棵树无限地扩展开来。%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/diagram1.png]]%0a%0a树状结构的一个关键的问题是父节点对子节点的管理问题。父节点需要能够添加、删除和遍历子节点。管理子节点的方法只对树枝节点有效，所以可以选择只为树枝节点定义子节点管理方法，也可以选择把管理方法定义为所有节点的公共接口以保持接口的统一。%0a根据这两种选择的不同，合成模式分为安全式和透明式。%0a%0a\\%0a\\%0a%0a[+++'''安全式'''+++]%0a%0a如果管理子节点的方法只在Composite/树枝节点中定义，这样的做法就是安全的做法，因为树叶类型的对象根本没有管理子节点的方法。如果客户端对树叶节点使用这些方法，程序会在编译期报错。%0a这种方式的缺点是不够透明，树叶类与树枝类具有不同的接口。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type1.png]]%0a%0a[+++''参与者：''+++]%0a1.	Component: 所有节点的公共接口，只定义公共方法，不定义管理子节点的方法。%0a2.	Leaf: 没有下级子对象的对象，是树状结构中的树叶。%0a3.	Composite: 有下级子对象的对象，是树状结构的树枝。拥有管理子对象的方法。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Component.java%0a%0apackage designPatterns.Composite.Type1;%0a%0apublic interface Component {%0a	public void sampleOperation();%0a	public Composite getComposite();%0a}%0a%0a// Source code from file:  Leaf.java%0a%0apackage designPatterns.Composite.Type1;%0a%0apublic class Leaf implements Component {%0a%0a	public void sampleOperation() {%0a		System.out.println("Leaf.sampleOperation()");%0a	}%0a	%0a	public Composite getComposite() {%0a		return null;%0a	}%0a}%0a%0a// Source code from file:  Composite.java%0a%0apackage designPatterns.Composite.Type1;%0a%0aimport java.util.*;%0a%0apublic class Composite implements Component {%0a%0a	@SuppressWarnings("unchecked")%0a	private Vector componentVector = new Vector();%0a	%0a	@SuppressWarnings("unchecked")%0a	public void sampleOperation() {%0a		System.out.println("Composite.sampleOperation()");%0a		Enumeration enu = getChilds();%0a		%0a		while(enu.hasMoreElements()) {%0a			((Component)enu.nextElement()).sampleOperation();%0a		}%0a	}%0a%0a	public Composite getComposite() {%0a		return this;%0a	}%0a	%0a	@SuppressWarnings("unchecked")%0a	public void addChild(Component component) {%0a		componentVector.addElement(component);%0a	}%0a	%0a	public void removeChild(Component component) {%0a		componentVector.removeElement(component);%0a	}%0a	%0a	@SuppressWarnings("unchecked")%0a	public Enumeration getChilds() {%0a		return componentVector.elements();%0a	}%0a}%0a(:sourcend:)%0a%0a\\%0a\\%0a%0a[+++'''透明式'''+++]%0a%0a如果管理子节点的方法(add()、remove（）和getChild()等)是在Component接口中定义的，这样的做法就是透明的做法。 这样做的好处是所有的构件类都有相同的接口，客户端可以同等地对待所有的对象。%0a%0a这种方式的缺点是不够安全，因为管理子节点的方法其实对树叶节点并不适用，它们并没有子节点，这些方法没有意义，在逻辑上也说不通。%0a%0a[+++''UML：''+++]%0a%25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type2.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type2.png]]%0a%0a[+++''参与者：''+++]%0a# Component: 所有节点的公共接口，只定义公共方法，定义了管理子节点的方法。%0a# Leaf: 没有下级子对象的对象，是树状结构中的树叶。由于在Component中定义了管理子节点的方法，所以这里也要实现这些方法的空的实现。%0a# Composite: 有下级子对象的对象，是树状结构的树枝。拥有管理子对象的方法。%0a%0a[+++''示例代码：''+++]%0a(:source lang=java:)%0a// Source code from file:  Component.java%0a%0apackage designPatterns.Composite.Type2;%0a%0aimport java.util.Enumeration;%0a%0apublic interface Component {%0a%0a	public void sampleOperation();%0a	public Composite getComposite();%0a	public void addChild(Component component);%0a	public void removeChild(Component component);%0a	@SuppressWarnings("unchecked")%0a	public Enumeration getChilds();%0a}%0a%0a// Source code from file:  Leaf.java%0a%0apackage designPatterns.Composite.Type2;%0a%0aimport java.util.Enumeration;%0a%0apublic class Leaf implements Component {%0a	%0a	@Override%0a	public void sampleOperation() {%0a		System.out.println("Leaf.sampleOperation()");%0a	}%0a	%0a	@Override%0a	public Composite getComposite() {%0a		return null;%0a	}%0a	%0a	@Override%0a	public void addChild(Component component) {%0a		// Do nothing%0a	}%0a	%0a	@Override%0a	public void removeChild(Component component) {%0a		// Do nothing%0a	}%0a	%0a	@SuppressWarnings("unchecked")%0a	@Override%0a	public Enumeration getChilds() {%0a		return null;%0a	}%0a%0a}%0a%0a// Source code from file:  Composite.java%0a%0apackage designPatterns.Composite.Type2;%0a%0aimport java.util.Enumeration;%0aimport java.util.Vector;%0a%0apublic class Composite implements Component {%0a	%0a	@SuppressWarnings("unchecked")%0a	private Vector componentVector = new Vector();%0a	%0a	@SuppressWarnings("unchecked")%0a	public void sampleOperation() {%0a		System.out.println("Composite.sampleOperation()");%0a		Enumeration enu = getChilds();%0a		%0a		while(enu.hasMoreElements()) {%0a			((Component)enu.nextElement()).sampleOperation();%0a		}%0a	}%0a	%0a	public Composite getComposite() {%0a		return this;%0a	}%0a	%0a	@SuppressWarnings("unchecked")%0a	public void addChild(Component component) {%0a		componentVector.addElement(component);%0a	}%0a	%0a	public void removeChild(Component component) {%0a		componentVector.removeElement(component);%0a	}%0a	%0a	@SuppressWarnings("unchecked")%0a	public Enumeration getChilds() {%0a		return componentVector.elements();%0a	}%0a%0a}%0a(:sourcend:)%0a%0a[+++''要点：''+++]%0a%0a在两种方式的示例代码中，接口Component接口都定义了一个有趣的方法public Composite getComposite()。在这个方法的实现中，Leaf类对象返回null，而Composite类对象返回this。%0a%0a我想这个方法的作用有两个：%0a# 一是可以区分对象的类型，如果返回值是null，说明对象是Leaf型；如果返回值不是null，说明对象是Composite型。%0a# 二是方便类型转换。这仅对Composite类型的意义。客户端如果确定了某个Component对象为Composite类型，接下来如果要调用Composite的某个方法（特别是它专有的方法）时，就需要先对这个Component作类型转换，转成Composite型，这并不能说是个好办法。而如果调用它的getComposite()方法，就可以直接拿到一个Composite对象，避免了直接类型转换。%0a
time=1319381094
author:1319381094=
diff:1319381094:1319036422:=15d14%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/diagram1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/diagram1.png]]%0a
host:1319381094=180.109.20.194
author:1319036422=
diff:1319036422:1319031886:=28,29c28%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type1.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type1.png]]%0a%3c %0a---%0a>  %0a112,113c111%0a%3c %25width=560 newwin%25 [[http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type2.png | http://www.the2ndmoon.net/uploads/DesignPattern/model/Composite/Type2.png]]%0a%3c %0a---%0a>  %0a
host:1319036422=117.89.207.43
author:1319031886=
diff:1319031886:1319031835:=99,100c99%0a%3c (:sourcend:)%0a%3c %0a---%0a> %0a212c211%0a%3c (:sourcend:)%0a---%0a> %0a
host:1319031886=117.89.207.43
author:1319031835=
diff:1319031835:1319031835:=1,219d0%0a%3c \\%0a%3c %0a%3c [+++'''合成模式/Composite'''+++]%0a%3c %0a%3c [+++''意图/适用场景：''+++]%0a%3c %0a%3c 合成模式又叫做部分-整体模式。它将对象组织到树结构中，可以用来描述整体与部分的关系。最显著的特点就是把整体与部分都抽象出统一的接口，这样客户端就可以把单纯元素与复合元素同等看待。%0a%3c %0a%3c 看下图所示的树状结构图。图中有两种节点，一种是树枝节点，一种是树叶节点。树根也是一种树枝节点，只不过它比较特殊，它没有父节点。%0a%3c %0a%3c 在构建这样的一种树状结构里，合成模式提供了三种元素：%0a%3c # Component: 它是所有“节点”的抽象接口，无论是树枝还是树叶，首先都是Component。%0a%3c # Leaf: 它是“树叶”的实现类，实现Component接口。%0a%3c # Composite: 它是“树枝”的实现类，实现Component接口。它也是合成模式的关键元素，因为它可以使得整棵树无限地扩展开来。%0a%3c %0a%3c 树状结构的一个关键的问题是父节点对子节点的管理问题。父节点需要能够添加、删除和遍历子节点。管理子节点的方法只对树枝节点有效，所以可以选择只为树枝节点定义子节点管理方法，也可以选择把管理方法定义为所有节点的公共接口以保持接口的统一。%0a%3c 根据这两种选择的不同，合成模式分为安全式和透明式。%0a%3c %0a%3c \\%0a%3c \\%0a%3c %0a%3c [+++'''安全式'''+++]%0a%3c %0a%3c 如果管理子节点的方法只在Composite/树枝节点中定义，这样的做法就是安全的做法，因为树叶类型的对象根本没有管理子节点的方法。如果客户端对树叶节点使用这些方法，程序会在编译期报错。%0a%3c 这种方式的缺点是不够透明，树叶类与树枝类具有不同的接口。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c 1.	Component: 所有节点的公共接口，只定义公共方法，不定义管理子节点的方法。%0a%3c 2.	Leaf: 没有下级子对象的对象，是树状结构中的树叶。%0a%3c 3.	Composite: 有下级子对象的对象，是树状结构的树枝。拥有管理子对象的方法。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Component.java%0a%3c %0a%3c package designPatterns.Composite.Type1;%0a%3c %0a%3c public interface Component {%0a%3c 	public void sampleOperation();%0a%3c 	public Composite getComposite();%0a%3c }%0a%3c %0a%3c // Source code from file:  Leaf.java%0a%3c %0a%3c package designPatterns.Composite.Type1;%0a%3c %0a%3c public class Leaf implements Component {%0a%3c %0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("Leaf.sampleOperation()");%0a%3c 	}%0a%3c 	%0a%3c 	public Composite getComposite() {%0a%3c 		return null;%0a%3c 	}%0a%3c }%0a%3c %0a%3c // Source code from file:  Composite.java%0a%3c %0a%3c package designPatterns.Composite.Type1;%0a%3c %0a%3c import java.util.*;%0a%3c %0a%3c public class Composite implements Component {%0a%3c %0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	private Vector componentVector = new Vector();%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("Composite.sampleOperation()");%0a%3c 		Enumeration enu = getChilds();%0a%3c 		%0a%3c 		while(enu.hasMoreElements()) {%0a%3c 			((Component)enu.nextElement()).sampleOperation();%0a%3c 		}%0a%3c 	}%0a%3c %0a%3c 	public Composite getComposite() {%0a%3c 		return this;%0a%3c 	}%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public void addChild(Component component) {%0a%3c 		componentVector.addElement(component);%0a%3c 	}%0a%3c 	%0a%3c 	public void removeChild(Component component) {%0a%3c 		componentVector.removeElement(component);%0a%3c 	}%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public Enumeration getChilds() {%0a%3c 		return componentVector.elements();%0a%3c 	}%0a%3c }%0a%3c %0a%3c \\%0a%3c \\%0a%3c %0a%3c [+++'''透明式'''+++]%0a%3c %0a%3c 如果管理子节点的方法(add()、remove（）和getChild()等)是在Component接口中定义的，这样的做法就是透明的做法。 这样做的好处是所有的构件类都有相同的接口，客户端可以同等地对待所有的对象。%0a%3c %0a%3c 这种方式的缺点是不够安全，因为管理子节点的方法其实对树叶节点并不适用，它们并没有子节点，这些方法没有意义，在逻辑上也说不通。%0a%3c %0a%3c [+++''UML：''+++]%0a%3c  %0a%3c [+++''参与者：''+++]%0a%3c # Component: 所有节点的公共接口，只定义公共方法，定义了管理子节点的方法。%0a%3c # Leaf: 没有下级子对象的对象，是树状结构中的树叶。由于在Component中定义了管理子节点的方法，所以这里也要实现这些方法的空的实现。%0a%3c # Composite: 有下级子对象的对象，是树状结构的树枝。拥有管理子对象的方法。%0a%3c %0a%3c [+++''示例代码：''+++]%0a%3c (:source lang=java:)%0a%3c // Source code from file:  Component.java%0a%3c %0a%3c package designPatterns.Composite.Type2;%0a%3c %0a%3c import java.util.Enumeration;%0a%3c %0a%3c public interface Component {%0a%3c %0a%3c 	public void sampleOperation();%0a%3c 	public Composite getComposite();%0a%3c 	public void addChild(Component component);%0a%3c 	public void removeChild(Component component);%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public Enumeration getChilds();%0a%3c }%0a%3c %0a%3c // Source code from file:  Leaf.java%0a%3c %0a%3c package designPatterns.Composite.Type2;%0a%3c %0a%3c import java.util.Enumeration;%0a%3c %0a%3c public class Leaf implements Component {%0a%3c 	%0a%3c 	@Override%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("Leaf.sampleOperation()");%0a%3c 	}%0a%3c 	%0a%3c 	@Override%0a%3c 	public Composite getComposite() {%0a%3c 		return null;%0a%3c 	}%0a%3c 	%0a%3c 	@Override%0a%3c 	public void addChild(Component component) {%0a%3c 		// Do nothing%0a%3c 	}%0a%3c 	%0a%3c 	@Override%0a%3c 	public void removeChild(Component component) {%0a%3c 		// Do nothing%0a%3c 	}%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	@Override%0a%3c 	public Enumeration getChilds() {%0a%3c 		return null;%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c // Source code from file:  Composite.java%0a%3c %0a%3c package designPatterns.Composite.Type2;%0a%3c %0a%3c import java.util.Enumeration;%0a%3c import java.util.Vector;%0a%3c %0a%3c public class Composite implements Component {%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	private Vector componentVector = new Vector();%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public void sampleOperation() {%0a%3c 		System.out.println("Composite.sampleOperation()");%0a%3c 		Enumeration enu = getChilds();%0a%3c 		%0a%3c 		while(enu.hasMoreElements()) {%0a%3c 			((Component)enu.nextElement()).sampleOperation();%0a%3c 		}%0a%3c 	}%0a%3c 	%0a%3c 	public Composite getComposite() {%0a%3c 		return this;%0a%3c 	}%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public void addChild(Component component) {%0a%3c 		componentVector.addElement(component);%0a%3c 	}%0a%3c 	%0a%3c 	public void removeChild(Component component) {%0a%3c 		componentVector.removeElement(component);%0a%3c 	}%0a%3c 	%0a%3c 	@SuppressWarnings("unchecked")%0a%3c 	public Enumeration getChilds() {%0a%3c 		return componentVector.elements();%0a%3c 	}%0a%3c %0a%3c }%0a%3c %0a%3c %0a%3c [+++''要点：''+++]%0a%3c %0a%3c 在两种方式的示例代码中，接口Component接口都定义了一个有趣的方法public Composite getComposite()。在这个方法的实现中，Leaf类对象返回null，而Composite类对象返回this。%0a%3c %0a%3c 我想这个方法的作用有两个：%0a%3c # 一是可以区分对象的类型，如果返回值是null，说明对象是Leaf型；如果返回值不是null，说明对象是Composite型。%0a%3c # 二是方便类型转换。这仅对Composite类型的意义。客户端如果确定了某个Component对象为Composite类型，接下来如果要调用Composite的某个方法（特别是它专有的方法）时，就需要先对这个Component作类型转换，转成Composite型，这并不能说是个好办法。而如果调用它的getComposite()方法，就可以直接拿到一个Composite对象，避免了直接类型转换。%0a
host:1319031835=117.89.207.43
