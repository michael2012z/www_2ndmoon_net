version=pmwiki-2.2.6 ordered=1 urlencoded=1
agent=Mozilla/5.0 (Windows NT 6.0) AppleWebKit/535.2 (KHTML, like Gecko) Chrome/15.0.874.121 Safari/535.2
author=
charset=UTF-8
csum=
ctime=1322491212
host=180.109.20.119
name=Linux.VFSFile
rev=2
targets=Linux.VFSFile
text=!! File%0a%0aFile structures represent open files, that is, an inode together with a current (reading/writing) offset. The offset can be set by the lseek() system call. Note that instead of a pointer to the inode we have a pointer to the dentry - that means that the name used to open a file is known. In particular system calls like getcwd() are possible.%0a%0a(:source lang=c:)%0astruct file {%0a	/*%0a	 * fu_list becomes invalid after file_free is called and queued via%0a	 * fu_rcuhead for RCU freeing%0a	 */%0a	union {%0a		struct list_head	fu_list;%0a		struct rcu_head 	fu_rcuhead;%0a	} f_u;%0a	struct path		f_path;%0a#define f_dentry	f_path.dentry%0a#define f_vfsmnt	f_path.mnt%0a	const struct file_operations	*f_op;%0a%0a	/*%0a	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.%0a	 * Must not be taken from IRQ context.%0a	 */%0a	spinlock_t		f_lock;%0a#ifdef CONFIG_SMP%0a	int			f_sb_list_cpu;%0a#endif%0a	atomic_long_t		f_count;%0a	unsigned int 		f_flags;%0a	fmode_t			f_mode;%0a	loff_t			f_pos;%0a	struct fown_struct	f_owner;%0a	const struct cred	*f_cred;%0a	struct file_ra_state	f_ra;%0a%0a	u64			f_version;%0a#ifdef CONFIG_SECURITY%0a	void			*f_security;%0a#endif%0a	/* needed for tty driver, and maybe others */%0a	void			*private_data;%0a%0a#ifdef CONFIG_EPOLL%0a	/* Used by fs/eventpoll.c to link all the hooks to this file */%0a	struct list_head	f_ep_links;%0a#endif /* #ifdef CONFIG_EPOLL */%0a	struct address_space	*f_mapping;%0a#ifdef CONFIG_DEBUG_WRITECOUNT%0a	unsigned long f_mnt_write_state;%0a#endif%0a};%0a(:sourcend:)%0a%0a(:source lang=c:)%0astruct file_operations {%0a	struct module *owner;%0a	loff_t (*llseek) (struct file *, loff_t, int);%0a	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);%0a	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);%0a	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);%0a	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);%0a	int (*readdir) (struct file *, void *, filldir_t);%0a	unsigned int (*poll) (struct file *, struct poll_table_struct *);%0a	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);%0a	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);%0a	int (*mmap) (struct file *, struct vm_area_struct *);%0a	int (*open) (struct inode *, struct file *);%0a	int (*flush) (struct file *, fl_owner_t id);%0a	int (*release) (struct inode *, struct file *);%0a	int (*fsync) (struct file *, loff_t, loff_t, int datasync);%0a	int (*aio_fsync) (struct kiocb *, int datasync);%0a	int (*fasync) (int, struct file *, int);%0a	int (*lock) (struct file *, int, struct file_lock *);%0a	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);%0a	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);%0a	int (*check_flags)(int);%0a	int (*flock) (struct file *, int, struct file_lock *);%0a	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);%0a	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);%0a	int (*setlease)(struct file *, long, struct file_lock **);%0a	long (*fallocate)(struct file *file, int mode, loff_t offset,%0a			  loff_t len);%0a};%0a(:sourcend:)%0a%0aEach file is in two lists, with links through the fields f_list, f_ep_links.%0a%0a!!! f_list%0a%0aThe list with links through f_list was discussed above. It is the list of all files belonging to a given superblock. There is a second use: the tty driver collects all files that are opened instances of a tty in a list headed by tty->tty_files with links through the file field f_list. Conversely, these files point back at the tty via their field private_data.%0a%0a(This field private_data is also used elsewhere. For example, the proc code uses it to attach a struct seq_file to a file.)%0a%0a!!! f_ep_links (The event poll list)%0a%0aAll event poll items belonging to a given file are collected in a list with head f_ep_links, protected by the file field f_ep_lock. (For event poll stuff, see epoll_ctl(2).)%0a
time=1322570016
author:1322570016=
diff:1322570016:1322491212:=1,4d0%0a%3c !! File%0a%3c %0a%3c File structures represent open files, that is, an inode together with a current (reading/writing) offset. The offset can be set by the lseek() system call. Note that instead of a pointer to the inode we have a pointer to the dentry - that means that the name used to open a file is known. In particular system calls like getcwd() are possible.%0a%3c %0a5a2%0a> %0a52,96c49,50%0a%3c (:sourcend:)%0a%3c %0a%3c (:source lang=c:)%0a%3c struct file_operations {%0a%3c 	struct module *owner;%0a%3c 	loff_t (*llseek) (struct file *, loff_t, int);%0a%3c 	ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);%0a%3c 	ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);%0a%3c 	ssize_t (*aio_read) (struct kiocb *, const struct iovec *, unsigned long, loff_t);%0a%3c 	ssize_t (*aio_write) (struct kiocb *, const struct iovec *, unsigned long, loff_t);%0a%3c 	int (*readdir) (struct file *, void *, filldir_t);%0a%3c 	unsigned int (*poll) (struct file *, struct poll_table_struct *);%0a%3c 	long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);%0a%3c 	long (*compat_ioctl) (struct file *, unsigned int, unsigned long);%0a%3c 	int (*mmap) (struct file *, struct vm_area_struct *);%0a%3c 	int (*open) (struct inode *, struct file *);%0a%3c 	int (*flush) (struct file *, fl_owner_t id);%0a%3c 	int (*release) (struct inode *, struct file *);%0a%3c 	int (*fsync) (struct file *, loff_t, loff_t, int datasync);%0a%3c 	int (*aio_fsync) (struct kiocb *, int datasync);%0a%3c 	int (*fasync) (int, struct file *, int);%0a%3c 	int (*lock) (struct file *, int, struct file_lock *);%0a%3c 	ssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);%0a%3c 	unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);%0a%3c 	int (*check_flags)(int);%0a%3c 	int (*flock) (struct file *, int, struct file_lock *);%0a%3c 	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);%0a%3c 	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);%0a%3c 	int (*setlease)(struct file *, long, struct file_lock **);%0a%3c 	long (*fallocate)(struct file *file, int mode, loff_t offset,%0a%3c 			  loff_t len);%0a%3c };%0a%3c (:sourcend:)%0a%3c %0a%3c Each file is in two lists, with links through the fields f_list, f_ep_links.%0a%3c %0a%3c !!! f_list%0a%3c %0a%3c The list with links through f_list was discussed above. It is the list of all files belonging to a given superblock. There is a second use: the tty driver collects all files that are opened instances of a tty in a list headed by tty->tty_files with links through the file field f_list. Conversely, these files point back at the tty via their field private_data.%0a%3c %0a%3c (This field private_data is also used elsewhere. For example, the proc code uses it to attach a struct seq_file to a file.)%0a%3c %0a%3c !!! f_ep_links (The event poll list)%0a%3c %0a%3c All event poll items belonging to a given file are collected in a list with head f_ep_links, protected by the file field f_ep_lock. (For event poll stuff, see epoll_ctl(2).)%0a---%0a> %0a> (:sourcend:)%0a\ No newline at end of file%0a
host:1322570016=180.109.20.119
author:1322491212=
diff:1322491212:1322491212:=1,50d0%0a%3c (:source lang=c:)%0a%3c %0a%3c struct file {%0a%3c 	/*%0a%3c 	 * fu_list becomes invalid after file_free is called and queued via%0a%3c 	 * fu_rcuhead for RCU freeing%0a%3c 	 */%0a%3c 	union {%0a%3c 		struct list_head	fu_list;%0a%3c 		struct rcu_head 	fu_rcuhead;%0a%3c 	} f_u;%0a%3c 	struct path		f_path;%0a%3c #define f_dentry	f_path.dentry%0a%3c #define f_vfsmnt	f_path.mnt%0a%3c 	const struct file_operations	*f_op;%0a%3c %0a%3c 	/*%0a%3c 	 * Protects f_ep_links, f_flags, f_pos vs i_size in lseek SEEK_CUR.%0a%3c 	 * Must not be taken from IRQ context.%0a%3c 	 */%0a%3c 	spinlock_t		f_lock;%0a%3c #ifdef CONFIG_SMP%0a%3c 	int			f_sb_list_cpu;%0a%3c #endif%0a%3c 	atomic_long_t		f_count;%0a%3c 	unsigned int 		f_flags;%0a%3c 	fmode_t			f_mode;%0a%3c 	loff_t			f_pos;%0a%3c 	struct fown_struct	f_owner;%0a%3c 	const struct cred	*f_cred;%0a%3c 	struct file_ra_state	f_ra;%0a%3c %0a%3c 	u64			f_version;%0a%3c #ifdef CONFIG_SECURITY%0a%3c 	void			*f_security;%0a%3c #endif%0a%3c 	/* needed for tty driver, and maybe others */%0a%3c 	void			*private_data;%0a%3c %0a%3c #ifdef CONFIG_EPOLL%0a%3c 	/* Used by fs/eventpoll.c to link all the hooks to this file */%0a%3c 	struct list_head	f_ep_links;%0a%3c #endif /* #ifdef CONFIG_EPOLL */%0a%3c 	struct address_space	*f_mapping;%0a%3c #ifdef CONFIG_DEBUG_WRITECOUNT%0a%3c 	unsigned long f_mnt_write_state;%0a%3c #endif%0a%3c };%0a%3c %0a%3c (:sourcend:)%0a\ No newline at end of file%0a
host:1322491212=58.212.192.21
